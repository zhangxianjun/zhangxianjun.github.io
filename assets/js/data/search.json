[ { "title": "AI Large Language Model", "url": "/posts/AI-Large-Language-Model/", "categories": "", "tags": "", "date": "2024-03-01 00:00:00 +0000", "snippet": "生态介绍基础模型 GPT-4 LLaMA Bard中间件 LangChain Chroma Pinecone应用层（AIGC） ChatGPT GitHub Copilot Midjourney演进Attention机制TransformerBERT/GPT", "content": "生态介绍基础模型 GPT-4 LLaMA Bard中间件 LangChain Chroma Pinecone应用层（AIGC） ChatGPT GitHub Copilot Midjourney演进Attention机制TransformerBERT/GPT" }, { "title": "二层", "url": "/posts/%E4%BA%8C%E5%B1%82/", "categories": "", "tags": "", "date": "2024-02-01 00:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "支付", "url": "/posts/%E6%94%AF%E4%BB%98/", "categories": "", "tags": "", "date": "2024-01-01 00:00:00 +0000", "snippet": "", "content": "" }, { "title": "钱包", "url": "/posts/%E9%92%B1%E5%8C%85%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2023-12-01 00:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "Bitcoin Ordinals笔记", "url": "/posts/Bitcoin-Ordinals%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2023-07-31 16:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "重读《微服务设计》笔记", "url": "/posts/%E9%87%8D%E8%AF%BB-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2023-06-30 16:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "读《架构整洁之道》", "url": "/posts/%E8%AF%BB-%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2023-05-31 16:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "重读《俞军产品方法论》", "url": "/posts/%E9%87%8D%E8%AF%BB-%E4%BF%9E%E5%86%9B%E4%BA%A7%E5%93%81%E6%96%B9%E6%B3%95%E8%AE%BA-%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2023-04-30 16:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "如何让团队自运行", "url": "/posts/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%9B%A2%E9%98%9F%E8%87%AA%E8%BF%90%E8%A1%8C/", "categories": "", "tags": "", "date": "2023-03-31 16:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "ChatGTP思考", "url": "/posts/ChatGTP%E6%80%9D%E8%80%83/", "categories": "", "tags": "", "date": "2023-01-01 00:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "Kafka笔记", "url": "/posts/Kafka%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2022-11-30 16:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "gRPC笔记", "url": "/posts/GRPC%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2022-10-31 16:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "Ethereum智能合约", "url": "/posts/Ethereum%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/", "categories": "", "tags": "", "date": "2022-09-30 16:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "Solidity-8.0笔记", "url": "/posts/Solidity-8.0%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2022-08-01 00:00:00 +0000", "snippet": "特性 safe math custom errors functions outside contract import as alias create2类型bool public b = true;// uint = uint256 uint8 uint16uint public u = 123;int public i = -123;address public addr =0...", "content": "特性 safe math custom errors functions outside contract import as alias create2类型bool public b = true;// uint = uint256 uint8 uint16uint public u = 123;int public i = -123;address public addr =0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;bytes32 public b32 = 0x954ab4b2;函数external 被标记为 external 的函数只能通过合约的外部消息（例如交易）来调用，不能在合约内部直接调用。 与 public 类似，external 函数也会生成一个外部函数，并且调用这样的函数的成本相对较低，因为不需要将参数从内存复制到栈上。 无法访问内部状态：external 函数无法访问合约的内部状态变量或者其他 internal 或 private 函数。 视为常量函数：在 view 和 pure 函数中，如果不显式声明为 external，则默认为 external。view &amp; pure 读链上信息要用view pure纯函数constant 常量函数修改器contract FuncTest { modifier tm(uint x) { require(1==1, x); // 代表需要修改的函数 _; require(1==1, x); } function a(uint x) external tm(x) { int i = 1; } function b(uint x) external tm(x) { int i = 2; }}构造函数contract FuncTest { address public owner; uint public x; constructor(uint x) { owner = msg.sender; x = _x }}contract FuncTest { function add(uint x, uint y) external pure returns (uint) { return x + y; }}错误requirerevertassert" }, { "title": "价值思考", "url": "/posts/%E8%AF%BB-%E8%82%A1%E7%A5%A8%E5%A4%A7%E4%BD%9C%E6%89%8B%E6%93%8D%E7%9B%98%E6%9C%AF-%E7%AC%94%E8%AE%B0/", "categories": "语言", "tags": "", "date": "2022-06-30 16:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "GolangWeb开发", "url": "/posts/GolangWeb%E5%BC%80%E5%8F%91/", "categories": "语言", "tags": "", "date": "2022-05-31 16:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "Golang入门语法", "url": "/posts/Golang%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/", "categories": "语言", "tags": "", "date": "2022-04-30 16:00:00 +0000", "snippet": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、cont...", "content": "学习Golang的目标 能够看懂Golang工程的源码。 能够修改Golang工程的源码。关键字概览 package（包定义）、import（包导入） var（声明变量）、const（声明常量） map（声明map类型数据） interface（声明接口） type（声明自定义类型） struct（声明数据类型） func（声明函数和方法） break、case、continue、for、fallthrough、else、if、switch、goto、default（流程控制） return（函数返回） range（读取slice、map、channel数据） defer（推迟函数） go （并发） select（选择） chan（信道）关键代码片段 Hello, world! package main import \"fmt\" func main() {\tfmt.Println(\"Hello, 世界\")} " }, { "title": "操作系统", "url": "/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/", "categories": "语言", "tags": "", "date": "2022-04-30 16:00:00 +0000", "snippet": "计算机发展历史早期计算机（1940年代）：在早期计算机时代，计算机是为特定目的设计的，通常只能执行一种或少数几种任务。人们需要手动设置和调整硬件来运行程序，这样的过程非常繁琐。第一代计算机（1950年代初）：随着电子管技术的进步，第一代计算机开始出现。这些计算机通常只能同时运行一个程序。早期计算机的操作涉及手动插拔电缆、设定开关和跳线等。批处理系统（1950年代中期）：随着对计算机使用的需求...", "content": "计算机发展历史早期计算机（1940年代）：在早期计算机时代，计算机是为特定目的设计的，通常只能执行一种或少数几种任务。人们需要手动设置和调整硬件来运行程序，这样的过程非常繁琐。第一代计算机（1950年代初）：随着电子管技术的进步，第一代计算机开始出现。这些计算机通常只能同时运行一个程序。早期计算机的操作涉及手动插拔电缆、设定开关和跳线等。批处理系统（1950年代中期）：随着对计算机使用的需求增加，批处理系统应运而生。批处理系统允许一批作业被收集并一次性输入计算机，计算机按顺序执行这些作业，无需人工介入。操作系统概念的出现（1950年代末 - 1960年代初）：随着对计算机的需求不断增长，人们意识到需要一种更高级别的软件来管理计算机硬件和简化用户与计算机的交互。这时期，操作系统的概念开始形成。多道程序设计（1960年代）：多道程序设计使得计算机可以同时执行多个程序。这意味着计算机可以在一个程序等待外部事件的时候执行其他程序，提高了计算机的利用率。分时操作系统（1960年代 - 1970年代）：分时操作系统使得多个用户能够通过终端同时访问计算机系统，每个用户都感觉自己是唯一使用计算机的。这标志着操作系统变得更加交互式。个人计算机时代（1970年代末 - 1980年代）：随着个人计算机的兴起，操作系统变得更加用户友好。微软的MS-DOS和苹果的Macintosh系统是个人计算机时代的代表。" }, { "title": "Java和Go编程语言的区别", "url": "/posts/Java%E5%92%8CGo%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB/", "categories": "", "tags": "", "date": "2022-04-01 00:00:00 +0000", "snippet": "Java和Go应用场景存在交集，理论上彼此能够替代，多数情况下没有必要这么做。一.生态 Java有一个庞大的生态系统，拥有丰富的库和框架，广泛应用于企业级开发、Web开发、大数据等多个领域。 Go的生态系统相对年轻，但在云原生、分布式系统、网络编程、区块链等领域也有广泛应用，尤其适合构建轻量级的服务。二.语法1.面向对象 Java的语法相对较为传统，有较多的面向对象特性。 Go的语法...", "content": "Java和Go应用场景存在交集，理论上彼此能够替代，多数情况下没有必要这么做。一.生态 Java有一个庞大的生态系统，拥有丰富的库和框架，广泛应用于企业级开发、Web开发、大数据等多个领域。 Go的生态系统相对年轻，但在云原生、分布式系统、网络编程、区块链等领域也有广泛应用，尤其适合构建轻量级的服务。二.语法1.面向对象 Java的语法相对较为传统，有较多的面向对象特性。 Go的语法相对简洁，更注重可读性和高效编程，没有传统的类和继承体系，而是采用接口实现。2.类型声明 Java： 类型声明是显式的，例如 int num = 10;。 Go： 类型声明可以是显式的，也可以是隐式的（使用 :=）。3.错误处理 Java：使用异常处理机制，例如try-catch块。 Go：使用返回错误值的方式进行错误处理。4.并发 Java: 并发模型主要基于线程；通过共享内存的方式来实现线程之间的通信。 Go: 基于goroutines来实现并发；通过通道进行通信。三.编译与运行 Java编译成字节码，通过Java虚拟机（JVM）运行，现在通过GraalVM也能生成机器码。 Go使用静态编译，直接生成本地机器码，无需虚拟机，执行速度较快。" }, { "title": "读《股票大作手操盘术》笔记", "url": "/posts/%E4%BA%A4%E6%98%93%E6%89%80/", "categories": "", "tags": "", "date": "2022-02-01 00:00:00 +0000", "snippet": "计算机发展历史早期计算机（1940年代）：在早期计算机时代，计算机是为特定目的设计的，通常只能执行一种或少数几种任务。人们需要手动设置和调整硬件来运行程序，这样的过程非常繁琐。第一代计算机（1950年代初）：随着电子管技术的进步，第一代计算机开始出现。这些计算机通常只能同时运行一个程序。早期计算机的操作涉及手动插拔电缆、设定开关和跳线等。批处理系统（1950年代中期）：随着对计算机使用的需求...", "content": "计算机发展历史早期计算机（1940年代）：在早期计算机时代，计算机是为特定目的设计的，通常只能执行一种或少数几种任务。人们需要手动设置和调整硬件来运行程序，这样的过程非常繁琐。第一代计算机（1950年代初）：随着电子管技术的进步，第一代计算机开始出现。这些计算机通常只能同时运行一个程序。早期计算机的操作涉及手动插拔电缆、设定开关和跳线等。批处理系统（1950年代中期）：随着对计算机使用的需求增加，批处理系统应运而生。批处理系统允许一批作业被收集并一次性输入计算机，计算机按顺序执行这些作业，无需人工介入。操作系统概念的出现（1950年代末 - 1960年代初）：随着对计算机的需求不断增长，人们意识到需要一种更高级别的软件来管理计算机硬件和简化用户与计算机的交互。这时期，操作系统的概念开始形成。多道程序设计（1960年代）：多道程序设计使得计算机可以同时执行多个程序。这意味着计算机可以在一个程序等待外部事件的时候执行其他程序，提高了计算机的利用率。分时操作系统（1960年代 - 1970年代）：分时操作系统使得多个用户能够通过终端同时访问计算机系统，每个用户都感觉自己是唯一使用计算机的。这标志着操作系统变得更加交互式。个人计算机时代（1970年代末 - 1980年代）：随着个人计算机的兴起，操作系统变得更加用户友好。微软的MS-DOS和苹果的Macintosh系统是个人计算机时代的代表。" }, { "title": "SaaS笔记", "url": "/posts/SaaS%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2021-12-01 00:00:00 +0000", "snippet": "​ 每个人经历不同，对事物的命名也不尽相同。透过表象的命名，找到底层的划分思想。用思想指导我们划分工程目录，普适性优先于特殊性，特殊性会存在入门门槛。系统性优先于便利性，便利性会让忽略整体。为什么要设计工程目录​ 不经过设计的工程目录，开发多个版本后会变的异常多样性。多样性会降低代码的可维护性，例如：数据库增删改查代码可以放到mapper目录下，也可以放jpa目录下，...", "content": "​ 每个人经历不同，对事物的命名也不尽相同。透过表象的命名，找到底层的划分思想。用思想指导我们划分工程目录，普适性优先于特殊性，特殊性会存在入门门槛。系统性优先于便利性，便利性会让忽略整体。为什么要设计工程目录​ 不经过设计的工程目录，开发多个版本后会变的异常多样性。多样性会降低代码的可维护性，例如：数据库增删改查代码可以放到mapper目录下，也可以放jpa目录下，如果两种情况同时存在，我们在查看代码时必定要从记忆中搜索一番才能找到地方。多样性不利于新加入成员的学习。如何设计工程目录简洁性唯一性代码组织形式由小到大分别是：方法，文件，文件夹，模块，SDK，应用。我们应坚持最小使用原则，能用方法承载绝不用文件承载。原因是越往上，要做的额外工作越多。调用形式本地方法调用，远程过程调用，HTTP调用，MessageQueue调用，依次调用依赖变弱，处理错误变的困难。工程目录的案例目录结构```textsrc├── main│ ├── java│ │ ├── api（接口层，响应其他服务）│ │ │ ├── grpc（供其他服调用）│ │ │ ├── cron（定时任务）│ │ │ └── http（供其他服调用）│ │ ├── dal（Data Access Layer）│ │ │ ├── mapper（调用数据库）│ │ │ ├── redis（调用缓存）│ │ │ ├── grpc（调用其他服务）│ │ │ └── http（调用其他服务）│ │ ├── domain│ │ │ ├── manager（两个以上service共同用到代码）│ │ │ └── service│ │ ├── kit（工具类）│ │ │ ├── DateKit│ │ │ └── HttpKit│ │ ├── infra（基础设施）│ │ │ ├── config│ │ │ ├── exception│ │ │ ├── gateway│ │ │ └── log│ │ ├── model（数据模型）│ │ │ ├── enums（业务枚举）│ │ │ ├── entity（领域模型）│ │ │ ├── po（数据库模型）│ │ │ ├── req（请求数据）│ │ │ └── resp（响应数据） │ │ ├── Application（主程序入口）│ │ └── Config（程序相关）│ └── resources│ │ ├── doc（接口文档）│ │ ├── mapper（sql代码）│ │ ├── application.yml（环境配置）│ │ └── smart-doc.json（接口文档配置）├── test├── .gitignore├── pom.xml└── README.md```解释目录结构 Api目录，用于响应客户端、网页、其他服务请求（请求方式：HTTP，WebSocket，GRPC）。 Dal目录，用户请求数据库，其他服务接口。 Domain目录，用户业务处理逻辑，对于多个service都用到的代码提取到manager目录下。 Kit目录，存放工具类，工具类与业务无关。对于普适性的工具，我们以maven的形式引入。 Infra目录，团队多数项目都会用到。 Model目录，存放所有的数据模型。 " }, { "title": "运维思考", "url": "/posts/%E8%BF%90%E7%BB%B4%E6%80%9D%E8%80%83/", "categories": "协作", "tags": "", "date": "2021-06-30 16:00:00 +0000", "snippet": "​ 每个人经历不同，对事物的命名也不尽相同。透过表象的命名，找到底层的划分思想。用思想指导我们划分工程目录，普适性优先于特殊性，特殊性会存在入门门槛。系统性优先于便利性，便利性会让忽略整体。为什么要设计工程目录​ 不经过设计的工程目录，开发多个版本后会变的异常多样性。多样性会降低代码的可维护性，例如：数据库增删改查代码可以放到mapper目录下，也可以放jpa目录下，...", "content": "​ 每个人经历不同，对事物的命名也不尽相同。透过表象的命名，找到底层的划分思想。用思想指导我们划分工程目录，普适性优先于特殊性，特殊性会存在入门门槛。系统性优先于便利性，便利性会让忽略整体。为什么要设计工程目录​ 不经过设计的工程目录，开发多个版本后会变的异常多样性。多样性会降低代码的可维护性，例如：数据库增删改查代码可以放到mapper目录下，也可以放jpa目录下，如果两种情况同时存在，我们在查看代码时必定要从记忆中搜索一番才能找到地方。多样性不利于新加入成员的学习。如何设计工程目录简洁性唯一性代码组织形式由小到大分别是：方法，文件，文件夹，模块，SDK，应用。我们应坚持最小使用原则，能用方法承载绝不用文件承载。原因是越往上，要做的额外工作越多。调用形式本地方法调用，远程过程调用，HTTP调用，MessageQueue调用，依次调用依赖变弱，处理错误变的困难。工程目录的案例目录结构```textsrc├── main│ ├── java│ │ ├── api（接口层，响应其他服务）│ │ │ ├── grpc（供其他服调用）│ │ │ ├── cron（定时任务）│ │ │ └── http（供其他服调用）│ │ ├── dal（Data Access Layer）│ │ │ ├── mapper（调用数据库）│ │ │ ├── redis（调用缓存）│ │ │ ├── grpc（调用其他服务）│ │ │ └── http（调用其他服务）│ │ ├── domain│ │ │ ├── manager（两个以上service共同用到代码）│ │ │ └── service│ │ ├── kit（工具类）│ │ │ ├── DateKit│ │ │ └── HttpKit│ │ ├── infra（基础设施）│ │ │ ├── config│ │ │ ├── exception│ │ │ ├── gateway│ │ │ └── log│ │ ├── model（数据模型）│ │ │ ├── enums（业务枚举）│ │ │ ├── entity（领域模型）│ │ │ ├── po（数据库模型）│ │ │ ├── req（请求数据）│ │ │ └── resp（响应数据） │ │ ├── Application（主程序入口）│ │ └── Config（程序相关）│ └── resources│ │ ├── doc（接口文档）│ │ ├── mapper（sql代码）│ │ ├── application.yml（环境配置）│ │ └── smart-doc.json（接口文档配置）├── test├── .gitignore├── pom.xml└── README.md```解释目录结构 Api目录，用于响应客户端、网页、其他服务请求（请求方式：HTTP，WebSocket，GRPC）。 Dal目录，用户请求数据库，其他服务接口。 Domain目录，用户业务处理逻辑，对于多个service都用到的代码提取到manager目录下。 Kit目录，存放工具类，工具类与业务无关。对于普适性的工具，我们以maven的形式引入。 Infra目录，团队多数项目都会用到。 Model目录，存放所有的数据模型。 " }, { "title": "如何设计工程目录", "url": "/posts/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95/", "categories": "协作", "tags": "", "date": "2021-05-31 16:00:00 +0000", "snippet": "每个人的经历各异，对事物的命名也因人而异。透过表面的命名，我们能够找到底层的划分思想。在制定工程目录时，我们应该以普适性为先，而不是特殊性，因为特殊性可能增加了入门的门槛。系统性应当优先于便利性，因为过于注重便利可能导致对整体结构的忽视。若工程目录缺乏经过深思熟虑的设计，随着多个版本的开发，目录结构可能会变得杂乱无章。多样性会降低代码的可维护性，比如说，数据库的增删改查代码可以统一放置在ma...", "content": "每个人的经历各异，对事物的命名也因人而异。透过表面的命名，我们能够找到底层的划分思想。在制定工程目录时，我们应该以普适性为先，而不是特殊性，因为特殊性可能增加了入门的门槛。系统性应当优先于便利性，因为过于注重便利可能导致对整体结构的忽视。若工程目录缺乏经过深思熟虑的设计，随着多个版本的开发，目录结构可能会变得杂乱无章。多样性会降低代码的可维护性，比如说，数据库的增删改查代码可以统一放置在mapper目录下，也可以放在jpa目录下。如果两者同时存在，我们在查看代码时必定需要费一番功夫从记忆中搜索才能找到所需位置。一.设计原型graph LRa(其他服务) --&gt; b(响应) --&gt; c(处理/逻辑) --&gt; d(请求) --&gt; e(其他服务)二.设计原则 代码的组织形式从小到大依次为：方法、文件、文件夹、模块、SDK、应用。我们应该始终遵循最小使用原则，这是因为随着级别的提高，额外的工作也随之增多。 调用形式有本地方法调用、远程过程调用、HTTP调用以及MessageQueue调用，依次调用会导致依赖关系逐渐减弱，然而，随之而来的是错误处理的困难。三.设计案例src├── main│ ├── java│ │ ├── api（接口层，响应其他服务）│ │ │ ├── grpc（供其他服调用）│ │ │ ├── cron（定时任务）│ │ │ └── http（供其他服调用）│ │ ├── dal（Data Access Layer）│ │ │ ├── mapper（调用数据库）│ │ │ ├── redis（调用缓存）│ │ │ ├── grpc（调用其他服务）│ │ │ └── http（调用其他服务）│ │ ├── domain│ │ │ ├── manager（两个以上service共同用到代码）│ │ │ └── service│ │ ├── kit（工具类）│ │ │ ├── DateKit│ │ │ └── HttpKit│ │ ├── infra（基础设施）│ │ │ ├── config│ │ │ ├── exception│ │ │ ├── gateway│ │ │ └── log│ │ ├── model（数据模型）│ │ │ ├── enums（业务枚举）│ │ │ ├── entity（领域模型）│ │ │ ├── po（数据库模型）│ │ │ ├── req（请求数据）│ │ │ └── resp（响应数据） │ │ ├── Application（主程序入口）│ │ └── Config（程序相关）│ └── resources│ ├── doc（接口文档）│ ├── mapper（sql代码）│ ├── application.yml（环境配置）│ └── smart-doc.json（接口文档配置）├── test├── .gitignore├── pom.xml└── README.md解释目录结构: api目录，用于响应客户端、网页、其他服务请求（请求方式：HTTP，WebSocket，GRPC）。 dal目录，用户请求数据库，其他服务接口。 domain目录，用户业务处理逻辑，对于多个service都用到的代码提取到manager目录下。 kit目录，存放工具类，工具类与业务无关。对于普适性的工具，我们以maven的形式引入。 infra目录，团队多数项目都会用到。 model目录，存放所有的数据模型。" }, { "title": "Ethereum笔记", "url": "/posts/Ethereum%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2021-04-30 16:00:00 +0000", "snippet": "区块链（Blockchain）是一种去中心化的、分布式的数据库技术。它的名字来源于它的基本结构，即由一个个数据块（block）链接而成的链（chain）。主要特征：去中心化，分布式数据库，不可篡改性，共识机制，加密技术，智能合约。一.区块链1.链结构classDiagramdirection LRclass BlockA { // 当前区块哈希 Object BlockHash ...", "content": "区块链（Blockchain）是一种去中心化的、分布式的数据库技术。它的名字来源于它的基本结构，即由一个个数据块（block）链接而成的链（chain）。主要特征：去中心化，分布式数据库，不可篡改性，共识机制，加密技术，智能合约。一.区块链1.链结构classDiagramdirection LRclass BlockA { // 当前区块哈希 Object BlockHash // 前一区块的哈希值 Object PreviousBlockHash}class BlockB { // 前一区块的哈希值 Object PreviousBlockHash // 当前区块哈希 Object BlockHash}BlockA &lt;-- BlockB2.块结构classDiagramdirection LRclass Block { // 区块头 BlockHeader BlockHeader // 区块哈希 Object BlockHash // 交易记录 TransactionList TransactionList}class BlockHeader { // 版本号 Object Version // 前一区块的哈希值 Object PreviousBlockHash // 默克尔树根 Object MerkleRoot // 时间戳 Object Timestamp // 挖矿目标难度Difficulty TargetTarget的紧凑格式 Object Bits // 随机数 Object Nonce}class TransactionList { // 用于奖励矿工将交易打包到区块 Coinbase Coinbase // 普通交易 Transaction Transaction}Block --&gt; BlockHeaderBlock --&gt; TransactionListMerkle RootMerkle Tree是一种哈希二叉树，用于归纳一个区块中的所有交易，同时生成整个交易集合的数字签名。计算过程 a.从区块交易列表中获取每对Txid，并对它们进行两次 Sha256 运算，得到哈希。 b.如果为奇数，则复制一份凑成偶数再进行两次 Sha256 运算，得到哈希。 c.递归a、b，直到最终获得一个哈希，它就是Merkle Root。优势 a.快速验证： Merkle Tree可以通过树的根哈希值来快速验证某个特定的数据块是否在树中。这对于在区块链中验证交易是否包含在特定的区块中非常有用，而不必验证整个区块。 b.节省空间： 将大量的数据组织成树状结构，最终只需要根哈希值，而不需要存储所有的中间哈希值。这节省了空间，并使得树的表示更为紧凑。 c.高效的数据一致性检查： 如果交易列表中的任何一个交易发生了变化，只需重新计算与该交易相关的Merkle路径，而不必重新计算整个树。这对于快速检测交易数据是否被篡改非常有用。 d.降低验证复杂度： Merkle Tree可以将数据分割成小块，从而降低验证的复杂度。当需要验证某个特定交易时，只需要计算沿着Merkle路径的哈希值，而不必遍历整个数据集。 e.隐私性： 在区块链中，Merkle Tree的结构可以帮助隐藏交易的具体内容，而只透露少量的信息。这有助于提高交易的隐私性。二.交易三.合约四.挖矿" }, { "title": "Bitcoin笔记", "url": "/posts/Bitcoin%E7%AC%94%E8%AE%B0/", "categories": "术", "tags": "", "date": "2021-03-31 16:00:00 +0000", "snippet": "区块链（Blockchain）是一种去中心化的、分布式的数据库技术。它的名字来源于它的基本结构，即由一个个数据块（block）链接而成的链（chain）。主要特征：去中心化，分布式数据库，不可篡改性，共识机制，加密技术，智能合约。区块链系统一般由数据层、网络层、共识层、激励层、合约层和应用层组成。一.区块链1.链结构classDiagramdirection LRclass BlockA {...", "content": "区块链（Blockchain）是一种去中心化的、分布式的数据库技术。它的名字来源于它的基本结构，即由一个个数据块（block）链接而成的链（chain）。主要特征：去中心化，分布式数据库，不可篡改性，共识机制，加密技术，智能合约。区块链系统一般由数据层、网络层、共识层、激励层、合约层和应用层组成。一.区块链1.链结构classDiagramdirection LRclass BlockA { // 当前区块哈希 Object BlockHash // 前一区块的哈希值 Object PreviousBlockHash}class BlockB { // 前一区块的哈希值 Object PreviousBlockHash // 当前区块哈希 Object BlockHash}BlockA &lt;-- BlockB2.块结构classDiagramdirection LRclass Block { // 区块头 BlockHeader BlockHeader // 区块哈希 Object BlockHash // 交易记录 TransactionList TransactionList}class BlockHeader { // 版本号 Object Version // 前一区块的哈希值 Object PreviousBlockHash // 默克尔树根 Object MerkleRoot // 时间戳 Object Timestamp // 挖矿目标难度Difficulty TargetTarget的紧凑格式 Object Bits // 随机数 Object Nonce}class TransactionList { // 用于奖励矿工将交易打包到区块 Coinbase Coinbase // 普通交易 Transaction Transaction}Block --&gt; BlockHeaderBlock --&gt; TransactionListMerkle RootMerkle Tree是一种哈希二叉树，用于归纳一个区块中的所有交易，同时生成整个交易集合的数字签名。计算过程 a.从区块交易列表中获取每对Txid，并对它们进行两次 Sha256 运算，得到哈希。 b.如果为奇数，则复制一份凑成偶数再进行两次 Sha256 运算，得到哈希。 c.递归a、b，直到最终获得一个哈希，它就是Merkle Root。优势 a.快速验证： Merkle Tree可以通过树的根哈希值来快速验证某个特定的数据块是否在树中。这对于在区块链中验证交易是否包含在特定的区块中非常有用，而不必验证整个区块。 b.节省空间： 将大量的数据组织成树状结构，最终只需要根哈希值，而不需要存储所有的中间哈希值。这节省了空间，并使得树的表示更为紧凑。 c.高效的数据一致性检查： 如果交易列表中的任何一个交易发生了变化，只需重新计算与该交易相关的Merkle路径，而不必重新计算整个树。这对于快速检测交易数据是否被篡改非常有用。 d.降低验证复杂度： Merkle Tree可以将数据分割成小块，从而降低验证的复杂度。当需要验证某个特定交易时，只需要计算沿着Merkle路径的哈希值，而不必遍历整个数据集。 e.隐私性： 在区块链中，Merkle Tree的结构可以帮助隐藏交易的具体内容，而只透露少量的信息。这有助于提高交易的隐私性。二.交易graph LRa(生成交易) --&gt; b(广播交易) --&gt; c(工作量证明) --&gt; d(广播区块) --&gt; e(验证区块) --&gt; g(记录到区块链) c(工作量证明)--&gt; d1(记录到区块链)graph LRa(矿场内存池) --&gt; b(验证交易) --&gt; c(等待被打包) --&gt; d(Hash运算)b(验证交易) --&gt; c1(验证失败) 比特币交易的基本单位是未经使用的一个交易输出，简称UTXO。1． FROM（谁发送的）它包括两部分：一是Previous Tx，也就是说，花的任何一笔钱都应有人转给你，需要出示账单的ID；二是Script Si，就是把单子用你的私钥做Hash（哈希算法），只有你能做这个Hash。2．TO（谁接受的）这包括两部分：一是Value，即要发多少；二是Script Pub Key，即对方的公钥，比特币账户就是一段公钥。三.合约四.挖矿" }, { "title": "密码学笔记", "url": "/posts/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2021-02-28 16:00:00 +0000", "snippet": "一.编码 Base64 编码： 将二进制数据编码成文本形式的一种编码方式。Base64编码使用64个字符（A-Z、a-z、0-9、+、/）来表示二进制数据。 URL 编码（Percent Encoding）： 将URL中的非ASCII字符和特殊字符以百分比编码表示。例如，空格会被编码为%20。二.哈希函数哈希函数是一种将任意长度的输入数据转换为固定长度的输出数据的数学函数。 MD5（M...", "content": "一.编码 Base64 编码： 将二进制数据编码成文本形式的一种编码方式。Base64编码使用64个字符（A-Z、a-z、0-9、+、/）来表示二进制数据。 URL 编码（Percent Encoding）： 将URL中的非ASCII字符和特殊字符以百分比编码表示。例如，空格会被编码为%20。二.哈希函数哈希函数是一种将任意长度的输入数据转换为固定长度的输出数据的数学函数。 MD5（Message Digest Algorithm 5）： 128位哈希函数，已被广泛认为不安全，不建议用于安全性要求高的场景。 SHA-1（Secure Hash Algorithm 1）： 160位哈希函数，也已经被破解，不再被视为安全。 SHA-256、SHA-384、SHA-512： 这是 SHA-2 系列的哈希函数，分别产生256位、384位和512位的哈希值。目前，SHA-256 是较为常见和安全的选择。 SHA-3： 由NIST设计的哈希函数标准，提供了不同的哈希长度，例如 SHA3-224、SHA3-256、SHA3-384、SHA3-512。三.对称加密对称加密，使用相同的密钥进行加密和解密。 DES（Data Encryption Standard）： DES 是一种早期的对称加密算法，使用56位密钥，但由于其密钥长度短，易受到暴力破解攻击，因此现在已经不推荐使用。 3DES（Triple DES）： 3DES 是 DES 的一种改进版本，使用两次或三次的 DES 加密过程，提供更高的安全性。尽管在现代加密中逐渐被淘汰，但在某些特定的环境中仍然在使用。 AES（Advanced Encryption Standard）： AES 是一种广泛使用的对称加密算法，被认为是目前最安全和高效的对称加密算法之一。它支持多种密钥长度，包括128位、192位和256位。四.非对称加密非对称加密（Asymmetric Encryption）使用一对密钥：公钥和私钥。1.算法 RSA（Rivest-Shamir-Adleman）： RSA 是最广泛使用的非对称加密算法之一。它基于大素数的难解性问题，其中公钥用于加密，私钥用于解密。 DSA（Digital Signature Algorithm）： DSA 主要用于数字签名。它使用一对密钥，其中私钥用于签名，公钥用于验证签名的真实性。 ECDSA（Elliptic Curve Digital Signature Algorithm）： ECDSA 是基于椭圆曲线密码学的数字签名算法，相对于DSA来说，它提供了相似的安全性，但使用更短的密钥长度。 ECDH（Elliptic Curve Diffie-Hellman）： ECDH 是一种密钥交换协议，它允许两个通信方在不共享密钥的情况下建立共享密钥。这个协议基于椭圆曲线密码学。 Diffie-Hellman： 尽管最初是一种对称密钥交换算法，但有一个非对称变体（DH），它使用非对称密钥而不是对称密钥来协商密钥。2.证书标准X.509X.509是一种定义了公钥证书标准的通用标准，主要特征和组成部分： 证书结构： X.509 证书包括一组字段，包含有关证书持有者（通常是实体或设备）的信息，以及证书的签发者、有效期、公钥等。这些字段使用 ASN.1（Abstract Syntax Notation One）编码。 数字签名： X.509 证书通常包含一个数字签名，该签名由证书颁发机构（CA）使用其私钥对证书的内容进行签名。验证者可以使用 CA 的公钥来验证证书的完整性和真实性。 公钥和私钥： X.509 证书包含公钥，该公钥用于加密或验证数字签名。私钥则由证书的拥有者持有，并用于解密或生成数字签名。 版本： 证书的版本字段指示证书的X.509版本。 扩展： X.509 证书可以包含扩展字段，用于提供附加信息，如密钥用途、密钥标识、证书策略等。 用途： 证书中的扩展字段可以指定证书的用途，例如 SSL/TLS 客户端身份验证、服务器身份验证、代码签名等。其他标准 PGP Certificates： Pretty Good Privacy（PGP）是一种用于加密和签名的通信协议，它使用 PGP 证书来支持密钥管理。PGP 证书包括用户的公钥和相关的身份信息。 SPKI（Simple Public Key Infrastructure）：SPKI 是一种轻量级的公钥基础设施标准，它定义了一种简单的证书格式，用于在 Internet 上进行身份验证和密钥交换。 OpenPGP Certificates： OpenPGP 是一种基于 PGP 的开放标准，用于支持电子邮件加密和签名。OpenPGP 证书是 X.509 证书的替代方案，用于验证密钥拥有者的身份。 ISO/IEC 7816： ISO/IEC 7816 标准定义了与集成电路卡（智能卡）相关的特性和接口。在智能卡领域，存在与数字证书相关的标准，这些标准规定了存储在智能卡上的数字证书的格式和使用方法。 Web of Trust (WoT)： Web of Trust 是一种不基于中心化 CA 的密钥验证方法，特别在 PGP 和 OpenPGP 签名中常见。在 Web of Trust 中，用户通过直接签署其他用户的公钥来建立信任关系。3.证书格式 X.509 PEM（Privacy Enhanced Mail）格式： X.509 PEM 格式是一种基于 ASCII 文本的证书表示形式，通常以 .pem、.crt、.cer 或 .key 为文件扩展名。PEM 文件以 —–BEGIN CERTIFICATE—– 和 —–END CERTIFICATE—– 之间的 BASE64 编码的证书数据开始和结束。 X.509 DER（Distinguished Encoding Rules）格式： X.509 DER 格式是一种二进制编码的证书表示形式，通常以 .der 或 .cer 为文件扩展名。DER 编码是基于 ASN.1（Abstract Syntax Notation One）规范的二进制表示。 PKCS#12/PFX（Personal Information Exchange Syntax Standard）格式： PKCS#12 是一种用于存储个人信息（包括证书和私钥）的标准，通常以 .pfx 或 .p12 为文件扩展名。PKCS#12 文件是二进制格式的，可以包含证书、私钥、证书链等信息，并且支持密码保护。 PKCS#7 格式： PKCS#7（Cryptographic Message Syntax）是一种通用的密码消息语法，可用于包含数字证书和其他加密信息。在证书领域，PKCS#7 格式通常以 .p7b 或 .p7c 为文件扩展名。 JKS（Java KeyStore）格式： JKS 是 Java KeyStore 的缩写，是 Java 中用于存储密钥和证书的专有格式。JKS 文件通常以 .jks 为文件扩展名。 NSSDB 格式： NSSDB 是 Mozilla Network Security Services（NSS）库使用的数据库文件格式，用于存储浏览器和其他应用程序使用的证书和密钥。4.椭圆曲线 secp256k1定义组织：SECG (Standards for Efficient Cryptography Group)。椭圆曲线：\\(y^2 = x^3 + 7 \\pmod p\\) 其中 p 是一个大素数，这个曲线被设计用于比特币的椭圆曲线数字签名算法。 P-256定义组织：NIST (National Institute of Standards and Technology)。椭圆曲线：\\(y^2 = x^3 - 3x + b \\pmod p\\) 其中 p 是一个大素数，b 是曲线的常数。5.密钥派生函数HKDF，全称为HMAC-based Key Derivation Function（基于HMAC的密钥派生函数），是一种用于从长期密钥派生出更短、更适用于特定用途的密钥的密码学函数。它的设计目的是提供安全的密钥派生，适用于各种密码协议和应用程序。HKDF由以下两个步骤组成： 提取（Extraction）：将长期密钥和可选的盐值通过一个伪随机函数（PRF）进行提取，得到一个固定长度的伪随机密钥。这个伪随机密钥将作为派生密钥的基础。 扩展（Expansion）：利用提取阶段得到的伪随机密钥，结合上下文信息（如果有的话），通过再次使用伪随机函数来生成最终的派生密钥。" }, { "title": "区块链笔记", "url": "/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2021-02-01 00:00:00 +0000", "snippet": "整体流程图Jenkins具体流程任务流程项目工程配置在/src/main/resources/目录下新建两个文件:一. DockerfileFROM lpicanco/java11-alpineADD dev-0.0.1-SNAPSHOT.jar app.jarEXPOSE 9911ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"]二. docker-compose.y...", "content": "整体流程图Jenkins具体流程任务流程项目工程配置在/src/main/resources/目录下新建两个文件:一. DockerfileFROM lpicanco/java11-alpineADD dev-0.0.1-SNAPSHOT.jar app.jarEXPOSE 9911ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"]二. docker-compose.ymlversion: \"3\"services: webapp: container_name: dev-demo-02 image: nexus.xxx.cn:8082/dev/dev-demo-02:v2 ports: - \"9915:9911\"任务创建流程一. 登录Jenkins地址账号密码二. 新建任务入口三. 创建任务名字（测试统一以dev前缀，正式以pro前缀）四. 填写任务描述（强制书写）五. 填写源码地址、打包分支、自己的git账号密码# demo地址https://xxxxxx/dev.git六. 取消构建触发器，勾选构建环境七. 新建执行shell脚本#!/bin/bash# 创建要docker打包的文件夹# ===================需要修改==========================# 镜像版本号version=\"v4\"# Jar端口号jarPort=\"9911\"# docker端口dockerPort=\"9916\"# 镜像名字dockerName=\"dev-demo-03\"# 部署服务器密码servicePasswd=\"xxxx\"# 部署服务器账户和地址 (用在Jenkins服务器上以jenkins用户连接一下部署服务器)serviceUrl=\"root@10.10.10.10\"# ===================需要修改==========================# 仓库地址nexusUrl=\"nexus.xxxx.cn:8082/dev/\"# 镜像地址dockerUrl=${nexusUrl}${dockerName}:${version}targetDir=${WORKSPACE}/target# 创建打包文件夹mkdir ${targetDir}/dockerecho 'mkdir success'# 切换到打包文件夹cd ${targetDir}/docker# 移动jar到打包文件下cp ${targetDir}/dev-0.0.1-SNAPSHOT.jar ./echo 'Copy jar success'# 把工程的Dockerfile文件移到打包目录cp ${WORKSPACE}/src/main/resources/Dockerfile ./echo \"Create Dockerfile success!\"# 编译成Docker镜像docker build -t ${dockerName} .# 打成标签docker tag ${dockerName} ${dockerUrl} # 推送到nexus仓库docker push ${dockerUrl}# 拷贝docker-compose.yml到目标服务器sshpass -p $servicePasswd scp ${WORKSPACE}/src/main/resources/docker-compose.yml ${serviceUrl}:/tmp/docker-compose # 登录目标服务器sshpass -p $servicePasswd ssh -tt ${serviceUrl} &lt;&lt; EOF# 停止运行的容器echo $servicePasswd | sudo -S docker stop ${dockerName}# 删除容器echo $servicePasswd | sudo -S docker rm ${dockerName}# 服务是否停止成功nc -zvw3 127.0.0.1 ${dockerPort}# 创建docker-compose文件夹#echo $servicePasswd | sudo -S mkdir /tmp/docker-compose# 进入docker-compose文件夹cd /tmp/docker-compose# 执行docker-compose.yml文件echo $servicePasswd | sudo -S docker-compose up -d# 服务是否停止成功nc -zvw3 127.0.0.1 ${dockerPort}exitEOFecho \"Deploy success\"八. 保存任务九. 点击立即构建进行构建，点击构建历史记录查看构建详情。十. 查看构建日志搜索 Connection refused 容器停止成功搜索 [tcp/*] succeeded! 容器启动成功配置目标服务器一. 创建daemon文件sudo vim /etc/docker/daemon.json二. 写入daemon文件的内容{ \"insecure-registries\": [ \"nexus.xxxx.cn:8082\" ]}三. 重启Dockersudo systemctl restart docker四. 登录镜像仓库sudo docker login nexus.xxxx.cn:8082五. 输入镜像仓库的账号密码" }, { "title": "MongoDB笔记", "url": "/posts/MongoDB%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2021-01-01 00:00:00 +0000", "snippet": "整体流程图Jenkins具体流程任务流程项目工程配置在/src/main/resources/目录下新建两个文件:一. DockerfileFROM lpicanco/java11-alpineADD dev-0.0.1-SNAPSHOT.jar app.jarEXPOSE 9911ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"]二. docker-compose.y...", "content": "整体流程图Jenkins具体流程任务流程项目工程配置在/src/main/resources/目录下新建两个文件:一. DockerfileFROM lpicanco/java11-alpineADD dev-0.0.1-SNAPSHOT.jar app.jarEXPOSE 9911ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"]二. docker-compose.ymlversion: \"3\"services: webapp: container_name: dev-demo-02 image: nexus.xxx.cn:8082/dev/dev-demo-02:v2 ports: - \"9915:9911\"任务创建流程一. 登录Jenkins地址账号密码二. 新建任务入口三. 创建任务名字（测试统一以dev前缀，正式以pro前缀）四. 填写任务描述（强制书写）五. 填写源码地址、打包分支、自己的git账号密码# demo地址https://xxxxxx/dev.git六. 取消构建触发器，勾选构建环境七. 新建执行shell脚本#!/bin/bash# 创建要docker打包的文件夹# ===================需要修改==========================# 镜像版本号version=\"v4\"# Jar端口号jarPort=\"9911\"# docker端口dockerPort=\"9916\"# 镜像名字dockerName=\"dev-demo-03\"# 部署服务器密码servicePasswd=\"xxxx\"# 部署服务器账户和地址 (用在Jenkins服务器上以jenkins用户连接一下部署服务器)serviceUrl=\"root@10.10.10.10\"# ===================需要修改==========================# 仓库地址nexusUrl=\"nexus.xxxx.cn:8082/dev/\"# 镜像地址dockerUrl=${nexusUrl}${dockerName}:${version}targetDir=${WORKSPACE}/target# 创建打包文件夹mkdir ${targetDir}/dockerecho 'mkdir success'# 切换到打包文件夹cd ${targetDir}/docker# 移动jar到打包文件下cp ${targetDir}/dev-0.0.1-SNAPSHOT.jar ./echo 'Copy jar success'# 把工程的Dockerfile文件移到打包目录cp ${WORKSPACE}/src/main/resources/Dockerfile ./echo \"Create Dockerfile success!\"# 编译成Docker镜像docker build -t ${dockerName} .# 打成标签docker tag ${dockerName} ${dockerUrl} # 推送到nexus仓库docker push ${dockerUrl}# 拷贝docker-compose.yml到目标服务器sshpass -p $servicePasswd scp ${WORKSPACE}/src/main/resources/docker-compose.yml ${serviceUrl}:/tmp/docker-compose # 登录目标服务器sshpass -p $servicePasswd ssh -tt ${serviceUrl} &lt;&lt; EOF# 停止运行的容器echo $servicePasswd | sudo -S docker stop ${dockerName}# 删除容器echo $servicePasswd | sudo -S docker rm ${dockerName}# 服务是否停止成功nc -zvw3 127.0.0.1 ${dockerPort}# 创建docker-compose文件夹#echo $servicePasswd | sudo -S mkdir /tmp/docker-compose# 进入docker-compose文件夹cd /tmp/docker-compose# 执行docker-compose.yml文件echo $servicePasswd | sudo -S docker-compose up -d# 服务是否停止成功nc -zvw3 127.0.0.1 ${dockerPort}exitEOFecho \"Deploy success\"八. 保存任务九. 点击立即构建进行构建，点击构建历史记录查看构建详情。十. 查看构建日志搜索 Connection refused 容器停止成功搜索 [tcp/*] succeeded! 容器启动成功配置目标服务器一. 创建daemon文件sudo vim /etc/docker/daemon.json二. 写入daemon文件的内容{ \"insecure-registries\": [ \"nexus.xxxx.cn:8082\" ]}三. 重启Dockersudo systemctl restart docker四. 登录镜像仓库sudo docker login nexus.xxxx.cn:8082五. 输入镜像仓库的账号密码" }, { "title": "WebSocket笔记", "url": "/posts/WebSocket%E7%AC%94%E8%AE%B0/", "categories": "开发工具", "tags": "", "date": "2020-11-30 16:00:00 +0000", "snippet": "整体流程图Jenkins具体流程任务流程项目工程配置在/src/main/resources/目录下新建两个文件:一. DockerfileFROM lpicanco/java11-alpineADD dev-0.0.1-SNAPSHOT.jar app.jarEXPOSE 9911ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"]二. docker-compose.y...", "content": "整体流程图Jenkins具体流程任务流程项目工程配置在/src/main/resources/目录下新建两个文件:一. DockerfileFROM lpicanco/java11-alpineADD dev-0.0.1-SNAPSHOT.jar app.jarEXPOSE 9911ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"]二. docker-compose.ymlversion: \"3\"services: webapp: container_name: dev-demo-02 image: nexus.xxx.cn:8082/dev/dev-demo-02:v2 ports: - \"9915:9911\"任务创建流程一. 登录Jenkins地址账号密码二. 新建任务入口三. 创建任务名字（测试统一以dev前缀，正式以pro前缀）四. 填写任务描述（强制书写）五. 填写源码地址、打包分支、自己的git账号密码# demo地址https://xxxxxx/dev.git六. 取消构建触发器，勾选构建环境七. 新建执行shell脚本#!/bin/bash# 创建要docker打包的文件夹# ===================需要修改==========================# 镜像版本号version=\"v4\"# Jar端口号jarPort=\"9911\"# docker端口dockerPort=\"9916\"# 镜像名字dockerName=\"dev-demo-03\"# 部署服务器密码servicePasswd=\"xxxx\"# 部署服务器账户和地址 (用在Jenkins服务器上以jenkins用户连接一下部署服务器)serviceUrl=\"root@10.10.10.10\"# ===================需要修改==========================# 仓库地址nexusUrl=\"nexus.xxxx.cn:8082/dev/\"# 镜像地址dockerUrl=${nexusUrl}${dockerName}:${version}targetDir=${WORKSPACE}/target# 创建打包文件夹mkdir ${targetDir}/dockerecho 'mkdir success'# 切换到打包文件夹cd ${targetDir}/docker# 移动jar到打包文件下cp ${targetDir}/dev-0.0.1-SNAPSHOT.jar ./echo 'Copy jar success'# 把工程的Dockerfile文件移到打包目录cp ${WORKSPACE}/src/main/resources/Dockerfile ./echo \"Create Dockerfile success!\"# 编译成Docker镜像docker build -t ${dockerName} .# 打成标签docker tag ${dockerName} ${dockerUrl} # 推送到nexus仓库docker push ${dockerUrl}# 拷贝docker-compose.yml到目标服务器sshpass -p $servicePasswd scp ${WORKSPACE}/src/main/resources/docker-compose.yml ${serviceUrl}:/tmp/docker-compose # 登录目标服务器sshpass -p $servicePasswd ssh -tt ${serviceUrl} &lt;&lt; EOF# 停止运行的容器echo $servicePasswd | sudo -S docker stop ${dockerName}# 删除容器echo $servicePasswd | sudo -S docker rm ${dockerName}# 服务是否停止成功nc -zvw3 127.0.0.1 ${dockerPort}# 创建docker-compose文件夹#echo $servicePasswd | sudo -S mkdir /tmp/docker-compose# 进入docker-compose文件夹cd /tmp/docker-compose# 执行docker-compose.yml文件echo $servicePasswd | sudo -S docker-compose up -d# 服务是否停止成功nc -zvw3 127.0.0.1 ${dockerPort}exitEOFecho \"Deploy success\"八. 保存任务九. 点击立即构建进行构建，点击构建历史记录查看构建详情。十. 查看构建日志搜索 Connection refused 容器停止成功搜索 [tcp/*] succeeded! 容器启动成功配置目标服务器一. 创建daemon文件sudo vim /etc/docker/daemon.json二. 写入daemon文件的内容{ \"insecure-registries\": [ \"nexus.xxxx.cn:8082\" ]}三. 重启Dockersudo systemctl restart docker四. 登录镜像仓库sudo docker login nexus.xxxx.cn:8082五. 输入镜像仓库的账号密码" }, { "title": "Dubbo笔记", "url": "/posts/Dubbo%E7%AC%94%E8%AE%B0/", "categories": "开发工具", "tags": "", "date": "2020-11-30 16:00:00 +0000", "snippet": "整体流程图Jenkins具体流程任务流程项目工程配置在/src/main/resources/目录下新建两个文件:一. DockerfileFROM lpicanco/java11-alpineADD dev-0.0.1-SNAPSHOT.jar app.jarEXPOSE 9911ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"]二. docker-compose.y...", "content": "整体流程图Jenkins具体流程任务流程项目工程配置在/src/main/resources/目录下新建两个文件:一. DockerfileFROM lpicanco/java11-alpineADD dev-0.0.1-SNAPSHOT.jar app.jarEXPOSE 9911ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"]二. docker-compose.ymlversion: \"3\"services: webapp: container_name: dev-demo-02 image: nexus.xxx.cn:8082/dev/dev-demo-02:v2 ports: - \"9915:9911\"任务创建流程一. 登录Jenkins地址账号密码二. 新建任务入口三. 创建任务名字（测试统一以dev前缀，正式以pro前缀）四. 填写任务描述（强制书写）五. 填写源码地址、打包分支、自己的git账号密码# demo地址https://xxxxxx/dev.git六. 取消构建触发器，勾选构建环境七. 新建执行shell脚本#!/bin/bash# 创建要docker打包的文件夹# ===================需要修改==========================# 镜像版本号version=\"v4\"# Jar端口号jarPort=\"9911\"# docker端口dockerPort=\"9916\"# 镜像名字dockerName=\"dev-demo-03\"# 部署服务器密码servicePasswd=\"xxxx\"# 部署服务器账户和地址 (用在Jenkins服务器上以jenkins用户连接一下部署服务器)serviceUrl=\"root@10.10.10.10\"# ===================需要修改==========================# 仓库地址nexusUrl=\"nexus.xxxx.cn:8082/dev/\"# 镜像地址dockerUrl=${nexusUrl}${dockerName}:${version}targetDir=${WORKSPACE}/target# 创建打包文件夹mkdir ${targetDir}/dockerecho 'mkdir success'# 切换到打包文件夹cd ${targetDir}/docker# 移动jar到打包文件下cp ${targetDir}/dev-0.0.1-SNAPSHOT.jar ./echo 'Copy jar success'# 把工程的Dockerfile文件移到打包目录cp ${WORKSPACE}/src/main/resources/Dockerfile ./echo \"Create Dockerfile success!\"# 编译成Docker镜像docker build -t ${dockerName} .# 打成标签docker tag ${dockerName} ${dockerUrl} # 推送到nexus仓库docker push ${dockerUrl}# 拷贝docker-compose.yml到目标服务器sshpass -p $servicePasswd scp ${WORKSPACE}/src/main/resources/docker-compose.yml ${serviceUrl}:/tmp/docker-compose # 登录目标服务器sshpass -p $servicePasswd ssh -tt ${serviceUrl} &lt;&lt; EOF# 停止运行的容器echo $servicePasswd | sudo -S docker stop ${dockerName}# 删除容器echo $servicePasswd | sudo -S docker rm ${dockerName}# 服务是否停止成功nc -zvw3 127.0.0.1 ${dockerPort}# 创建docker-compose文件夹#echo $servicePasswd | sudo -S mkdir /tmp/docker-compose# 进入docker-compose文件夹cd /tmp/docker-compose# 执行docker-compose.yml文件echo $servicePasswd | sudo -S docker-compose up -d# 服务是否停止成功nc -zvw3 127.0.0.1 ${dockerPort}exitEOFecho \"Deploy success\"八. 保存任务九. 点击立即构建进行构建，点击构建历史记录查看构建详情。十. 查看构建日志搜索 Connection refused 容器停止成功搜索 [tcp/*] succeeded! 容器启动成功配置目标服务器一. 创建daemon文件sudo vim /etc/docker/daemon.json二. 写入daemon文件的内容{ \"insecure-registries\": [ \"nexus.xxxx.cn:8082\" ]}三. 重启Dockersudo systemctl restart docker四. 登录镜像仓库sudo docker login nexus.xxxx.cn:8082五. 输入镜像仓库的账号密码" }, { "title": "Jenkins自动打包教程", "url": "/posts/Jenkins%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E6%95%99%E7%A8%8B/", "categories": "开发工具", "tags": "", "date": "2020-10-31 16:00:00 +0000", "snippet": "整体流程图Jenkins具体流程任务流程项目工程配置在/src/main/resources/目录下新建两个文件:一. DockerfileFROM lpicanco/java11-alpineADD dev-0.0.1-SNAPSHOT.jar app.jarEXPOSE 9911ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"]二. docker-compose.y...", "content": "整体流程图Jenkins具体流程任务流程项目工程配置在/src/main/resources/目录下新建两个文件:一. DockerfileFROM lpicanco/java11-alpineADD dev-0.0.1-SNAPSHOT.jar app.jarEXPOSE 9911ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"]二. docker-compose.ymlversion: \"3\"services: webapp: container_name: dev-demo-02 image: nexus.xxx.cn:8082/dev/dev-demo-02:v2 ports: - \"9915:9911\"任务创建流程一. 登录Jenkins地址账号密码二. 新建任务入口三. 创建任务名字（测试统一以dev前缀，正式以pro前缀）四. 填写任务描述（强制书写）五. 填写源码地址、打包分支、自己的git账号密码# demo地址https://xxxxxx/dev.git六. 取消构建触发器，勾选构建环境七. 新建执行shell脚本#!/bin/bash# 创建要docker打包的文件夹# ===================需要修改==========================# 镜像版本号version=\"v4\"# Jar端口号jarPort=\"9911\"# docker端口dockerPort=\"9916\"# 镜像名字dockerName=\"dev-demo-03\"# 部署服务器密码servicePasswd=\"xxxx\"# 部署服务器账户和地址 (用在Jenkins服务器上以jenkins用户连接一下部署服务器)serviceUrl=\"root@10.10.10.10\"# ===================需要修改==========================# 仓库地址nexusUrl=\"nexus.xxxx.cn:8082/dev/\"# 镜像地址dockerUrl=${nexusUrl}${dockerName}:${version}targetDir=${WORKSPACE}/target# 创建打包文件夹mkdir ${targetDir}/dockerecho 'mkdir success'# 切换到打包文件夹cd ${targetDir}/docker# 移动jar到打包文件下cp ${targetDir}/dev-0.0.1-SNAPSHOT.jar ./echo 'Copy jar success'# 把工程的Dockerfile文件移到打包目录cp ${WORKSPACE}/src/main/resources/Dockerfile ./echo \"Create Dockerfile success!\"# 编译成Docker镜像docker build -t ${dockerName} .# 打成标签docker tag ${dockerName} ${dockerUrl} # 推送到nexus仓库docker push ${dockerUrl}# 拷贝docker-compose.yml到目标服务器sshpass -p $servicePasswd scp ${WORKSPACE}/src/main/resources/docker-compose.yml ${serviceUrl}:/tmp/docker-compose # 登录目标服务器sshpass -p $servicePasswd ssh -tt ${serviceUrl} &lt;&lt; EOF# 停止运行的容器echo $servicePasswd | sudo -S docker stop ${dockerName}# 删除容器echo $servicePasswd | sudo -S docker rm ${dockerName}# 服务是否停止成功nc -zvw3 127.0.0.1 ${dockerPort}# 创建docker-compose文件夹#echo $servicePasswd | sudo -S mkdir /tmp/docker-compose# 进入docker-compose文件夹cd /tmp/docker-compose# 执行docker-compose.yml文件echo $servicePasswd | sudo -S docker-compose up -d# 服务是否停止成功nc -zvw3 127.0.0.1 ${dockerPort}exitEOFecho \"Deploy success\"八. 保存任务九. 点击立即构建进行构建，点击构建历史记录查看构建详情。十. 查看构建日志搜索 Connection refused 容器停止成功搜索 [tcp/*] succeeded! 容器启动成功配置目标服务器一. 创建daemon文件sudo vim /etc/docker/daemon.json二. 写入daemon文件的内容{ \"insecure-registries\": [ \"nexus.xxxx.cn:8082\" ]}三. 重启Dockersudo systemctl restart docker四. 登录镜像仓库sudo docker login nexus.xxxx.cn:8082五. 输入镜像仓库的账号密码" }, { "title": "HTTP笔记", "url": "/posts/HTTP%E7%AC%94%E8%AE%B0/", "categories": "架构", "tags": "", "date": "2020-01-01 00:00:00 +0000", "snippet": "七个面向对象设计原则①单一职责原则（Single Responsibility Principle，SRP）意味着一个类应该只有一个引起变化的原因。换句话说，一个类应该只负责一个功能领域中的一组相关的功能。②开闭原则（Open-Closed Principle，OCP）软件实体（类、模块、函数等等）应该对扩展开放，对修改关闭。这意味着可以通过添加新的代码来扩展现有的功能，而不必修改现有的代码...", "content": "七个面向对象设计原则①单一职责原则（Single Responsibility Principle，SRP）意味着一个类应该只有一个引起变化的原因。换句话说，一个类应该只负责一个功能领域中的一组相关的功能。②开闭原则（Open-Closed Principle，OCP）软件实体（类、模块、函数等等）应该对扩展开放，对修改关闭。这意味着可以通过添加新的代码来扩展现有的功能，而不必修改现有的代码。③里氏代换原则（Liskov Substitution Principle，LSP）子类型必须能够替换其基类型，而不影响程序的正确性。即，如果一个类是某个抽象类的子类，那么它应该可以替代该抽象类的任何地方，而不引起错误。④依赖倒转原则（Dependency Inversion Principle，DIP）高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于具体，而具体应该依赖于抽象。⑤接口隔离原则（Interface Segregation Principle，ISP）一个类对于它的客户不应该有不需要的方法。这意味着应该将大的接口拆分成更小的、更具体的接口，以便客户端只需知道与其相关的方法。⑥合成复用原则（Composite Reuse Principle，CRP）尽量使用合成/聚合，而不是继承来实现代码的复用。通过将已有的对象纳入新对象中，新对象可以调用已有对象的功能，从而实现代码复用。⑦迪米特法则（Law of Demeter，LoD）一个对象应该对其他对象保持最小的了解。换句话说，一个类对于它直接调用的类知道得越少越好。这有助于减少系统的耦合。三大类设计模式根据它们的用途，设计模式可分为创建型（Creational）、结构型（Structural）和行为型（Behavioral）3种。其中，创建型模式主要用于描述如何创建对象；结构型模式主要用于描述如何实现类或对象的组合；行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。设计模式一览表如下：创建型1.单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。结构型行为型" }, { "title": "Istio笔记", "url": "/posts/Istio%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2019-12-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "Kubernetes笔记", "url": "/posts/Elasticsearch%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2019-11-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "Elasticsearch笔记", "url": "/posts/Kubernetes%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2019-10-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "Docker笔记", "url": "/posts/Docker%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2019-10-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "日志系统笔记", "url": "/posts/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2019-08-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "远程过程调用笔记", "url": "/posts/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2019-07-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "事务笔记1", "url": "/posts/%E4%BA%8B%E5%8A%A1%E7%AC%94%E8%AE%B01/", "categories": "", "tags": "", "date": "2019-06-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "消息队列", "url": "/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/", "categories": "", "tags": "", "date": "2019-05-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "微服务笔记", "url": "/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2019-04-01 00:00:00 +0000", "snippet": "注册中心配置中心负载均衡网关分布式事务", "content": "注册中心配置中心负载均衡网关分布式事务" }, { "title": "设计模式", "url": "/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/", "categories": "术", "tags": "", "date": "2019-02-28 16:00:00 +0000", "snippet": "七个面向对象设计原则①单一职责原则（Single Responsibility Principle，SRP）意味着一个类应该只有一个引起变化的原因。换句话说，一个类应该只负责一个功能领域中的一组相关的功能。②开闭原则（Open-Closed Principle，OCP）软件实体（类、模块、函数等等）应该对扩展开放，对修改关闭。这意味着可以通过添加新的代码来扩展现有的功能，而不必修改现有的代码...", "content": "七个面向对象设计原则①单一职责原则（Single Responsibility Principle，SRP）意味着一个类应该只有一个引起变化的原因。换句话说，一个类应该只负责一个功能领域中的一组相关的功能。②开闭原则（Open-Closed Principle，OCP）软件实体（类、模块、函数等等）应该对扩展开放，对修改关闭。这意味着可以通过添加新的代码来扩展现有的功能，而不必修改现有的代码。③里氏代换原则（Liskov Substitution Principle，LSP）子类型必须能够替换其基类型，而不影响程序的正确性。即，如果一个类是某个抽象类的子类，那么它应该可以替代该抽象类的任何地方，而不引起错误。④依赖倒转原则（Dependency Inversion Principle，DIP）高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于具体，而具体应该依赖于抽象。⑤接口隔离原则（Interface Segregation Principle，ISP）一个类对于它的客户不应该有不需要的方法。这意味着应该将大的接口拆分成更小的、更具体的接口，以便客户端只需知道与其相关的方法。⑥合成复用原则（Composite Reuse Principle，CRP）尽量使用合成/聚合，而不是继承来实现代码的复用。通过将已有的对象纳入新对象中，新对象可以调用已有对象的功能，从而实现代码复用。⑦迪米特法则（Law of Demeter，LoD）一个对象应该对其他对象保持最小的了解。换句话说，一个类对于它直接调用的类知道得越少越好。这有助于减少系统的耦合。三大类设计模式根据它们的用途，设计模式可分为创建型（Creational）、结构型（Structural）和行为型（Behavioral）3种。其中，创建型模式主要用于描述如何创建对象；结构型模式主要用于描述如何实现类或对象的组合；行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。设计模式一览表如下：创建型1.单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。结构型行为型" }, { "title": "Spring-boot-启动流程", "url": "/posts/Spring-boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/", "categories": "", "tags": "", "date": "2019-02-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "开发流程梳理", "url": "/posts/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/", "categories": "协作", "tags": "", "date": "2018-11-30 16:00:00 +0000", "snippet": "无论团队是否有明确的书面开发流程，实际上，“开发流程”已经在团队中自然形成，只是其深度和专业程度的发展程度有所不同。作为基层管理者，我们应该建立一套明确的开发流程，通过在不同项目中的不断优化，为公司提高生产效率和产品质量提供有力支持。一.产品周期graph LRa(需求) --&gt; b(生产) --&gt; c(销售) --&gt; a(需求)c --&gt; d(结束)先有产品周期，再...", "content": "无论团队是否有明确的书面开发流程，实际上，“开发流程”已经在团队中自然形成，只是其深度和专业程度的发展程度有所不同。作为基层管理者，我们应该建立一套明确的开发流程，通过在不同项目中的不断优化，为公司提高生产效率和产品质量提供有力支持。一.产品周期graph LRa(需求) --&gt; b(生产) --&gt; c(销售) --&gt; a(需求)c --&gt; d(结束)先有产品周期，再有开发流程，开发流程始终依附于产品周期。二.开发流程graph LRa((验收需求)) --&gt; b(程序设计) --&gt; c(开发计划) --&gt; d(编码) --&gt; e((联调)) --&gt; f(测试) --&gt; g(部署) --&gt; h(维护)对于大多数临时团队而言，在实际操作中，往往未能清晰地划分开发阶段，需求确认和程序设计往往混在编码阶段一同完成。虽然混合进行看似节省时间，但在实践中却发现这样做会增加团队的沟通成本。明确了开发流程后，我们应该在相应的环节留下清晰的工作痕迹，因为这个留痕的过程也是我们深入思考业务的过程。三.工作职责1.验收需求我们经常说程序中存在BUG，而需求本身也不例外，同样可能存在BUG。需求中的问题主要分为两类：一是产品人员和需求方未能真正达成共识，二是产品人员和开发人员在设计方面存在各自的理解偏差。验收需求的目的在于消除大家对产品的理解偏差，达成共识。尽早消除这些偏差，可以减少团队在沟通上浪费的时间，同时提高产品的质量。验收需求前程序员要做如下工作： 预习原型 产品会议 流程是否完善 提出疑问 定义是否清晰 提出方案 设计图和原型是否一致   记录疑问   预想实现方案   无论是产品人员还是开发人员，总是希望能够详尽地表达自己的想法。需求验收阶段即便想法尚未完全成熟，也要提前表达出来。因为产品开发是一个不断迭代的过程，每一次沟通和碰撞都是推动产品朝着更优秀方向发展的过程。2.程序设计设计始终应该优先于编码。苏格拉底曾言：“未经审视的人生，是不值得过的。” 类似地，没有经过充分设计的程序，都是不值得进行编码的。编码得越多，偏差就会愈加显著。 设计 会议 主流程 ✅ 数据库 ✅ 接口文档 ✅ 主流程设计，是一个识别任务优先级的过程，是一个部署开发人员协同工作的过程。数据库设计是统一业务模型的过程，接口文档是推演数据流转的过程。3.开发计划“计划赶不上变化”，开发计划具有动态性，是要不断调整的。开发计划的作用是提醒待完成的工作，避免工作量暴涨暴跌。开发任务的颗粒度最大为2小时，颗粒度太大会低估工作量。每天下班前标注完成的任务、删除废弃的任务、增加意外的任务。开发计划模板如下： 任务 开始时间 结束时间 工时 执行人 备注 状态 对接阿里云短信发送接口 20220101 20220101 2 孙悟空   ✅ 对接腾讯云短信发送接口 20220101 20220101 2 孙悟空   ✅ 对接AWS邮件发送接口 20220101 20220101 2 孙悟空   ✅ 4.编码编码工作内容有四部分：调用参数校验，业务逻辑，返回参数，单元测试。业务逻辑部分一定要先写注释或画流程图，再进行编码。5.联调优先走通主流程，主流程通畅的情况下，开发团队能够更迅速地发现和解决主要的问题。这有助于集中注意力解决关键功能上的错误或缺陷，确保软件的核心功能能够正常运作。通过首先确保主流程正常工作，可以有效降低整个系统的风险。在联调的早期阶段解决主要问题，有助于避免在后期阶段出现更严重的、难以解决的问题。6.测试除了配合测试人员进行问题修复，还要体验产品，在体验产品的过程中发现自己的问题并及时订正，核对自己负责模块数据是否和设计保持一致。7.部署撰写部署文档，部署文档内容包含操作流程、程序运行配置、数据库脚本、源码仓库地址。8.维护线上问题处理，线上日志监控、代码优化。" }, { "title": "Maven笔记", "url": "/posts/Maven%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2018-11-01 00:00:00 +0000", "snippet": "Maven可以翻译为“专家”或“内行”，用于项目构建、依赖管理和项目信息管理。它是一个异常强大的构建工具，能够帮我们自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。一.开发流程概览graph LRa((验收需求)) --&gt; b(程序设计) --&gt; c(开发计划) --&gt; d(编码) --&gt; e((联调)) --&gt; f(测试) --&gt; g(部署...", "content": "Maven可以翻译为“专家”或“内行”，用于项目构建、依赖管理和项目信息管理。它是一个异常强大的构建工具，能够帮我们自动化构建过程，从清理、编译、测试到生成报告，再到打包和部署。一.开发流程概览graph LRa((验收需求)) --&gt; b(程序设计) --&gt; c(开发计划) --&gt; d(编码) --&gt; e((联调)) --&gt; f(测试) --&gt; g(部署) --&gt; h(维护)二.工作职责1.验收需求预习原型 流程是否完善 定义是否清晰 设计图和原型是否一致 记录疑问 预想实现方案产品会议 提出疑问 提出方案2.程序设计 主流程图 数据库设计 接口文档3.开发计划4.编码5.联调6.测试7.部署8.维护" }, { "title": "Java并发编程", "url": "/posts/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/", "categories": "", "tags": "", "date": "2018-10-01 00:00:00 +0000", "snippet": "一.特性 原子性 可见性 有序性二.锁分类1.悲观锁&amp;乐观锁 悲观锁（synchronized/ReentrantLock/ReentrantReadWriteLock） 乐观锁（CompareAndSwap）悲观锁获取不到资源后，会挂起当前线程。需要用户和内核态之间切换。2.可重入锁&amp;不可重入锁public class ReentrantLockExample {...", "content": "一.特性 原子性 可见性 有序性二.锁分类1.悲观锁&amp;乐观锁 悲观锁（synchronized/ReentrantLock/ReentrantReadWriteLock） 乐观锁（CompareAndSwap）悲观锁获取不到资源后，会挂起当前线程。需要用户和内核态之间切换。2.可重入锁&amp;不可重入锁public class ReentrantLockExample { public static void main(String[] args) { SharedResource sharedResource = new SharedResource(); // 创建两个线程，并启动它们 Thread t1 = new Thread(() -&gt; sharedResource.doSomething(), \"Thread 1\"); Thread t2 = new Thread(() -&gt; sharedResource.doSomething(), \"Thread 2\"); t1.start(); t2.start(); }}public class SharedResource { // synchronized方法，实现了锁的重入 public synchronized void doSomething() { String threadName = Thread.currentThread().getName(); System.out.println(threadName + \" entering doSomething.\"); // 调用另一个synchronized方法，锁的重入 doSomethingElse(); System.out.println(threadName + \" leaving doSomething.\"); } // 另一个synchronized方法，锁的重入 public synchronized void doSomethingElse() { String threadName = Thread.currentThread().getName(); System.out.println(threadName + \" entering doSomethingElse.\"); // 这里可以进一步调用其他synchronized方法，锁的重入 System.out.println(threadName + \" leaving doSomethingElse.\"); }}3.公平锁&amp;非公平锁 synchronized仅支持非公平锁 ReentrantLock默认是非公平锁，支持公平锁。4.互斥锁&amp;共享锁 synchronized/ReetrantLock 共享锁：读多写少,ReetrantReadWriteLock三.synchronized/ReetrantLock 语法和用法：synchronized 是 Java 关键字，可以直接用于方法或代码块中，用于对方法或代码块进行同步。使用 synchronized 时，不需要显式地创建锁对象。ReentrantLock 是一个类，位于 java.util.concurrent.locks 包中，它提供了更灵活的锁操作。使用 ReentrantLock 时，需要显式地创建锁对象，并在需要同步的代码块中调用 lock() 方法获取锁，并在结束时调用 unlock() 方法释放锁。 可中断性：synchronized 不支持锁的中断操作，一旦获取锁的线程进入了阻塞状态，其他线程只能等待锁的释放。ReentrantLock 提供了 lockInterruptibly() 方法，可以在等待锁时响应中断，即使线程处于等待状态，也可以通过中断来中止等待。 条件等待：ReentrantLock 提供了与锁关联的条件变量（Condition），可以通过 await() 和 signal() 或 signalAll() 方法实现线程间的等待和通知。synchronized 不直接支持条件等待，但可以通过 Object 的 wait()、notify() 和 notifyAll() 方法来实现类似的功能。 性能和灵活性：ReentrantLock 相比 synchronized 提供了更多的功能和灵活性，比如超时获取锁、公平性设置、锁的多种获取方式等，但相应地增加了一些额外的开销。synchronized 是 JVM 内置的关键字，使用更简单、更直观，适用于大多数简单的同步需求。Compare And SwapJava Unsafe1.synchronizeda.锁消除JIT编译器做的优化，没有共享资源时，消除不必要的锁，提升性能。b.锁粗化JIT编译器做的优化，扩大锁的范围，避免频繁的加锁释放锁。c.锁升级 无锁（延迟4秒开启偏向锁机制前）/匿名偏向锁（延迟4秒开启偏向锁机制后） 当前对象没有作为锁资源 偏向锁 只有一个A线程，直接偏向A线程；来一个B线程来获取，发现被A线程持有，B线程拿锁失败，做锁升级，撤销偏向锁；来一个B线程来获取，发现没有现成持有，直接更改为B现成持有。调用hashCode直接升级为重量级锁。 轻量级锁 自旋锁（多次执行CAS）;CAS失败达到自旋阈值，做锁升级。 重量级锁，失败线程挂起。 无法重量到偏向降级，偏向到无锁可以降级，匿名偏向锁时调用hasCode会降级为无锁状态。graph LRobject(创建对象) --延迟开启偏向锁前--&gt; no_lock(无锁) --线程持有当前锁--&gt; light_lock(轻量级锁) --CAS到达阈值--&gt; heavy_lock(重量级锁)object(创建对象) --延迟开启偏向锁后--&gt; anonymous(匿名偏向锁) --线程持有当前锁--&gt; bias(偏向锁) --调用hashCode/竞争激烈--&gt; heavy_lock(重量级锁)anonymous(匿名偏向锁) --调用hashCode--&gt; no_lock(无锁)bias(偏向锁) --竞争不激烈--&gt; light_lock(轻量级锁)2.ReetrantLock lock方法实现不同：非公平锁，会在lock方法中直接执行CAS，尝试将state从0改为1，如果失败才调用acquire方法；公平锁，在lock方法中，直接acquire。 tryAcquire方法实现不同：非公平锁，在state为0时，直接CAS抢锁；公平锁，在state为0时，查看是否有排队的节点，才会根据情况尝试CAS抢锁。a.非公平锁graph LRta(线程A) --&gt; lock(加锁) --&gt; cas(CAS) --&gt; state(state从0改为1) --&gt; success(加锁成功)graph LRtb(线程B) --&gt; lock(加锁) --&gt; cas(CAS) --&gt; state{state从0改为1} --失败--&gt; again_lock(加锁) --&gt; is_state{判断state是否为0} --是--&gt; try_state{尝试state从0改为1} --成功--&gt; success(加锁成功)try_state{尝试state从0改为1} --失败--&gt; fail(失败，准备排队)is_state{判断state是否为0} --否--&gt; is_self{是否自己持有} --是--&gt; relock(重入逻辑) is_self{是否自己持有} --否--&gt; self_success(加锁失败，准备排队) graph LRqueue(排队) --&gt; package(封装线程为Node) --&gt; add(添加到AQS双向链表) --&gt; has_head(是否存在head节点) --无--&gt; init(创建head) --&gt; position(判断是否head.next位置)has_head(是否存在head节点) --有--&gt; position(判断是否head.next位置) --是--&gt; try_lock(再次加锁) --成功--&gt; success(成功)try_lock(再次加锁) --失败--&gt; hang(挂起) position(判断是否head.next位置) --否--&gt; hang(挂起) b.公平锁graph LRta(线程A) --&gt; lock(加锁) --&gt; is_state{判断state是否为0} --是--&gt; is_queue{双向链表是否有排队的Node} --否--&gt; success(CAS将state从0改为1)graph LRtb(线程B) --&gt; lock(加锁) --&gt; cas(CAS) --&gt; state{state从0改为1} --失败--&gt; again_lock(加锁) --&gt; is_state{判断state是否为0} --是--&gt; try_state{尝试state从0改为1} --成功--&gt; success(加锁成功)try_state{尝试state从0改为1} --失败--&gt; fail(失败，准备排队)is_state{判断state是否为0} --否--&gt; is_self{是否自己持有} --是--&gt; relock(重入逻辑) is_self{是否自己持有} --否--&gt; self_success(加锁失败，准备排队) graph LRqueue(排队) --&gt; package(封装线程为Node) --&gt; add(添加到AQS双向链表) --&gt; has_head(是否存在head节点) --无--&gt; init(创建head) --&gt; position(判断是否head.next位置)has_head(是否存在head节点) --有--&gt; position(判断是否head.next位置) --是--&gt; try_lock(再次加锁) --成功--&gt; success(成功)try_lock(再次加锁) --失败--&gt; hang(挂起) position(判断是否head.next位置) --否--&gt; hang(挂起) 对象在内存中的存储布局（Java Object Layout）markword（8字节=64位）补全Markword图 JVM会延迟4秒，开启偏向锁机制。JVM启动时，使用ClassLoader将大量的Class对象加载到内存中，loadClass方法有synchronized关键字，无锁状态直接升级为轻量级锁。跳过偏向锁因为偏向锁有撤销机制，撤销寻找安全点非常耗时。class pointer 指向类的指针instance data 事例数据padding 补齐8字节线程状态进程是程序执行的一个实例，线程是cpu任务调度的最小执行单位，每个线程拥有自己独立的程序计数器、虚拟机栈、本地方法栈。 线程状态```mermaidgraph LRnew(创建) –start–&gt; runnable(运行) –执行完成–&gt; terminal(死亡)runnable(运行) –synchronized–&gt; blocked(阻塞)runnable(运行) —-&gt; waiting(无限期等待)runnable(运行) —&gt; timed-waiting(限期等待)## 创建线程## 线程池## 线程同步从join/sleep角度解决存在问题。## 进程：资源分配的基本单位线程：程序执行的基本单位Linux线程调度器：线程切换 context switch cpu ## synchronized### CAScompare and swapcompare and exchange### Java Object layout* mark word 8字节* class pointer 4个字节* instance data* padding ### 锁升级### 锁消除StringBuffer对象不被其他线程使用，JVM会自动消除StringBuffer对象的锁### 重入锁### JIT （Just in time）即时编译，热点代码直接编译成机器码。### Synchronized1. 字节码：通过 monitorenter 和 monitorexit 指令来实现。2. 锁升级3. lock comxchg### Cache Line一个缓存行包含多个字节的数据，通常是64字节，缓存行是为了提高内存访问效率而设计的，通过预取（Prefetching）相邻的数据，充分利用空间局部性，减少对主存的访问次数，提高计算机系统的整体性能。### MESI 协议每个缓存行的四种状态：* Modified（M）：缓存行已被修改，且与主存中的数据不一致。其他 CPU 中可能有缓存副本，需要在写回主存之前进行更新或者写回操作。* Exclusive（E）：缓存行与主存中的数据一致，且没有其他 CPU 中的缓存副本。当前 CPU 是唯一持有该缓存行的 CPU。* Shared（S）：缓存行与主存中的数据一致，且可能存在其他 CPU 中的缓存副本。多个 CPU 共享相同的数据。* Invalid（I）：缓存行无效，不包含有效数据。需要从主存中重新加载数据。当一个 CPU 写入一个缓存行时，它首先将状态设置为 Modified，并且在写回主存之前，其他 CPU 不能访问该缓存行。如果其他 CPU 持有相同缓存行的 Exclusive 或 Shared 副本，那么这些副本将被标记为 Invalid。当一个 CPU 读取一个缓存行时，如果该缓存行在 Exclusive 或 Shared 状态，那么状态保持不变。如果在 Modified 状态，需要将数据拷贝到当前 CPU，并将状态设置为 Exclusive。当一个 CPU 修改了一个缓存行，如果状态是 Shared，那么需要将状态设置为 Modified，并且通知其他 CPU 该缓存行已经无效。如果状态是 Exclusive，则直接修改数据。X86 CPU 一致性协议通常是指 MESI 协议（Modified, Exclusive, Shared, Invalid）。CPU缓存一致性协议，缓存hang缓存行8个字节，缓存行对齐。数据超过缓存行大小，保持线程之间数据一致性用锁总线方法。```mermaidgraph LRcpu(CPU) --&gt; l1(L1) --&gt; l2(L2) --&gt; ram(主存储器)Volatile 线程可见性（A线程修改了值，B线程可以读到） 禁止指令重排（JVM内存屏障:内存屏障两边的指令不可以重排）source code: volatilebyte code: acc_volatilejvm jre：内存屏障，四种屏障。hotspot实现：lock 锁总线 超线程：2核4线程，一个ALU（）对应多个PC和Registersnew对象过程graph LRa(类加载) --&gt; b(类初始化) --&gt; c(内存分配) --&gt; d(对象初始化) --&gt; f(对象引用)c(内存分配) --&gt; g(对象引用) --&gt; h(对象初始化) 类加载： 首先，Java虚拟机会根据类的全限定名（fully qualified name）来加载类的字节码文件。这个过程发生在类第一次被使用的时候。 类初始化： 在类加载后，虚拟机会对类进行初始化，包括执行静态代码块和静态变量的赋值。这一步在类的生命周期中只会执行一次。 内存分配： 当使用new关键字创建对象时，Java虚拟机会在堆内存中为对象分配一块内存空间。 对象初始化： 分配内存后，虚拟机会对对象进行初始化，包括对实例变量的默认初始化和执行构造方法。如果有父类，会先调用父类的构造方法。 对象引用： 在对象初始化完成后，new表达式会返回对象的引用（reference），该引用可以被赋值给一个变量，或者作为参数传递给其他方法。" }, { "title": "Java虚拟机加载类笔记", "url": "/posts/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2018-09-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "Java内存管理", "url": "/posts/Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/", "categories": "", "tags": "", "date": "2018-08-01 00:00:00 +0000", "snippet": "一.内存管理技术 引用计数是一种简单的内存管理技术，它在内存中的每个对象上维护一个计数器，记录该对象被引用的次数。 根可达算法是一种内存管理技术，通过从根对象（通常是程序的全局变量或者线程栈上的对象）出发，搜索所有能被根对象直接或间接引用到的对象，并将这些对象视为“活跃对象”，而没有被找到的对象则可以被认为是“垃圾对象”。二.垃圾回收算法1.标记清除 定义：标记清除是一种基本的垃圾回收...", "content": "一.内存管理技术 引用计数是一种简单的内存管理技术，它在内存中的每个对象上维护一个计数器，记录该对象被引用的次数。 根可达算法是一种内存管理技术，通过从根对象（通常是程序的全局变量或者线程栈上的对象）出发，搜索所有能被根对象直接或间接引用到的对象，并将这些对象视为“活跃对象”，而没有被找到的对象则可以被认为是“垃圾对象”。二.垃圾回收算法1.标记清除 定义：标记清除是一种基本的垃圾回收算法，分为两个阶段：标记阶段和清除阶段。 工作原理：标记阶段：从根对象出发，递归地遍历所有可达对象，并标记它们。清除阶段：遍历整个堆内存，清除未被标记的对象，即未被任何引用所指向的对象，释放其内存空间。 优点：简单直观，能够处理循环引用。 缺点：可能产生内存碎片，清除阶段的暂停时间较长。2.拷贝 定义：拷贝是一种高效的垃圾回收算法，通常用于实现新生代垃圾回收。 工作原理：将堆内存分为两个区域，一个区域作为活动空间，另一个作为闲置空间。当活动空间的内存分配满时，将存活的对象复制到闲置空间，并清除活动空间中的所有对象，然后交换两个空间的角色。 优点：避免了内存碎片化，减少了清除的时间，适用于小内存环境。 缺点：需要额外的内存空间，不能处理大对象和长期存活的对象。3.标记压缩 定义：标记压缩是一种综合了标记清除和内存整理的垃圾回收算法。 工作原理：标记阶段：与标记清除相同，标记所有可达对象。压缩阶段：将所有存活的对象向堆的一端移动，然后将所有未移动的内存释放，从而消除内存碎片。 优点：减少了内存碎片，提高了内存利用率，适用于大内存环境。 缺点：需要额外的内存空间进行移动，可能会增加内存使用。" }, { "title": "Java Stream 笔记", "url": "/posts/Java-Stream-%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2018-07-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "Java泛型笔记", "url": "/posts/Java%E6%B3%A8%E8%A7%A3%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2018-06-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "Java泛型笔记", "url": "/posts/Java%E6%B3%9B%E5%9E%8B%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2018-05-01 00:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "MyBatis入门篇", "url": "/posts/MyBatis%E7%AC%94%E8%AE%B0/", "categories": "中间件", "tags": "", "date": "2018-04-30 16:00:00 +0000", "snippet": "为什么要使用MyBatisMyBatis是一款优秀的持久层框架, 用于简化数据库操作的代码，通过简单的XML或注解,和数据库字段做映射。使用MyBatisMyBatis源码WHYWHATHOW", "content": "为什么要使用MyBatisMyBatis是一款优秀的持久层框架, 用于简化数据库操作的代码，通过简单的XML或注解,和数据库字段做映射。使用MyBatisMyBatis源码WHYWHATHOW" }, { "title": "Java语言笔记", "url": "/posts/Java%E9%9B%86%E5%90%88%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2018-03-31 16:00:00 +0000", "snippet": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引...", "content": "引用类型引用类型是为了控制对象的生命周期。由高到低依次为：强引用、软引用、弱引用和虚引用。强引用强引用是默认的引用类型，它会使对象处于可触及状态，只有在没有任何强引用指向对象时，垃圾回收器才会考虑回收该对象。软引用在系统内存不足时，垃圾回收器会尝试回收被软引用指向的对象，但它会在真正没有足够内存时才回收。弱引用弱引用允许垃圾回收器回收被引用的对象，即使有弱引用指向该对象，只要该对象没有被强引用持有。虚引用主要是为了防止出现那些无法被回收的对象8 bits = 1 Byte1024 Byte = 1 KB1024 KB = 1 MB2018.1.Linux后台运行2.Java集合3.Java泛型4.Java注解5.Java Stream6.Java内存管理7.虚拟机类加载机制8.Java多线程2019.01 微服务实现方案对比-配置中心-服务发现-负载均衡-服务网关-服务熔断- 日志方案 消息队列 事务处理 " }, { "title": "Nginx入门篇", "url": "/posts/Nginx%E5%85%A5%E9%97%A8%E7%AF%87/", "categories": "中间件", "tags": "", "date": "2018-02-28 16:00:00 +0000", "snippet": "配置文件记录# 定义后端服务器组upstream serverapi { server 127.0.0.1:8000;}server { listen 80; server_name ; client_max_body_size 2m; # 定义对于/的请求如何处理 location / { root /data/w...", "content": "配置文件记录# 定义后端服务器组upstream serverapi { server 127.0.0.1:8000;}server { listen 80; server_name ; client_max_body_size 2m; # 定义对于/的请求如何处理 location / { root /data/www/cow-admin-agent-web/; index index.html; autoindex on; } location /api { # 允许所有来源的请求访问 add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'; # 将请求代理到后端服务器组。 proxy_pass http://serverapi; } }" }, { "title": "Redis笔记", "url": "/posts/Redis%E7%AC%94%E8%AE%B0/", "categories": "中间件", "tags": "", "date": "2018-01-31 16:00:00 +0000", "snippet": "Redis是Remote Dictionary Server（远程字典服务器）的缩写，Redis数据库中的所有数据都存储在内存中，由于内存的读写速度远快于硬盘，因此Redis在性能上对比其他基于硬盘存储的数据库有非常明显的优势。一.命令1.字符串类型# 获取符合规则的键名列表, ?一个字符, *任意字符KEYS# 判断一个键是否存在EXISTS key# 删除键DEL key DEL k1 ...", "content": "Redis是Remote Dictionary Server（远程字典服务器）的缩写，Redis数据库中的所有数据都存储在内存中，由于内存的读写速度远快于硬盘，因此Redis在性能上对比其他基于硬盘存储的数据库有非常明显的优势。一.命令1.字符串类型# 获取符合规则的键名列表, ?一个字符, *任意字符KEYS# 判断一个键是否存在EXISTS key# 删除键DEL key DEL k1 k2# 获取键值的数据类型TYPE key# 赋值与取值SET key valueGET key# 递增/递减数字DECR keyINCR key# 增加/减少指定的整数INCRBY key incrementDECRBY key decrement# 向末尾追加值APPEND key value# 获取字符串长度STRLEN key # 获取/设置多个键值MGET k1 k2MSET k1 v1 k2 v2 2.哈希类型# 获取/设置哈希类型HSET key field valueHGET key fieldHMSET key f1 v1 f2 v2 HMGET key f1 f2HGETALL key# 判断一个键是否存在HEXISTS key# 当字段不存在时赋值,是原子操作。HSETNX key field value# 增加数字HINCRBY key field increment# 删除字段HDEL key field# 只获取字段名或字段值HKEYS keyHVALS key# 获取字段数量HLEN key3.列表类型列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为O(1)，获取的元素越接近两端速度就越快。# 向列表两端增加元素LPUSH key valueRPUSH key value# 从列表两端弹出元素LPOP keyRPOP key# 获取列表中元素的个数LLEN key# 获取列表片段LRANGE key start stop# 获取/设置指定索引的元素值LINDEX key indexLSET key index value# 只保留列表指定片段LTRIM key start end4.集合类型由于集合类型在Redis内部是使用值为空的哈希表（hash table）实现的，因此这些操作的时间复杂度都是O(1)。# 增加/删除元素SADD key memberSREM key member# 获取集合中的所有元素SMEMBERS key# 判断元素是否在集合中SISMEMBER key member# 集合间运算SDIFF k1 k2 SINTER k1 k2SUNION k1 k25.有序集合类型有序集合类型是使用哈希表和跳表（skip list）实现的，所以即使读取位于中间部分的数据速度也很快，时间复杂度是O(logN)，有序集合类型为集合中的每个元素都关联了一个分数。列表类型是通过链表实现的，获取靠近两端的数据时速度极快，而当元素数量增多后，访问中间部分数据的速度会较慢，有序集合比列表类型更耗费内存。# 增加元素ZADD key score member# 获取元素的分数ZSCORE key member# 获取排名在某个范围内的元素列表ZRANGE key start stop ZREVRANGE key start stop# 增加某个元素的分数ZINCRBY key increment member6.流类型列表类型可以在头部和中间插入内容，而日志没有类似的需求，所以流类型也只支持在末尾追加内容。流类型在插入一个新条目时可以自动为其生成一个在流中的唯一ID（类似于日志的行号）。# 增加条目XADD key [MAXLEN [=|~] threshold] *|ID field value [field value ...]# 根据ID来按范围查询条目XRANGE key start end [COUNT count]# 删除指定元素XDEL key ID7.事务Redis中的事务（transaction）是一组命令的集合。事务同命令一样都是Redis的最小执行单位，一个事务中的命令要么都执行，要么都不执行。Redis的事务机制并不支持事务回滚。# 开启事务MULTI# 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。# 如果使用WATCH命令监控了一个具有过期时间的键，该键时间到期自动删除不会被WATCH命令认为该键键值被改变。WATCH#取消监控UNWATCH# 执行事务EXEC8.排序# BY pattern 用于指定一个外部键（external key）的模式# LIMIT 用于限制排序结果的范围。offset 表示起始位置，count 表示返回的元素数量。# GET 用于获取排序结果中元素的值。# ASC|DESC 用于指定排序的顺序，可以是升序（ASC）或降序（DESC）。# ALPHA 用于指定排序时对字符串进行字典排序而不是数值排序。# STORE 用于将排序的结果保存到指定的键 SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]性能优化: 尽可能减少待排序键中的元素个数（使n尽可能小）。 使用LIMIT参数只获取需要的数据（使m尽可能小）。 如果要排序的数据数量较大，尽可能使用STORE参数将结果缓存。9.队列BRPOP命令和RPOP命令相似，唯一的区别是当列表中没有元素时BRPOP命令会一直阻塞连接，直到有新元素加入。LPUSH queue taskBRPOP queue 010.发布/订阅# 发布PUBLISH channel message# 订阅SUBSCRIBE channel11.流与消费组对列表来说，当多个客户端执行BRPOP命令来监听一个列表时，一条消息只会被一个客户端接收到；对“发布/订阅”来说，当多个客户端通过SUBSCRIBE命令监听消息时，一条消息会被所有客户端接收到；流则同时支持这两种模式。# 创建消费组，MKSTREAM参数用来说明如果指定的流不存在，那么就创建一个流。XGROUP CREATE stream group $ MKSTREAM# *这是消息的唯一标识符（ID）。message通常用于存储消息的实际内容。XADD stream * message A# 读流XREADGROUP GROUP group c1 COUNT 1 STREAMS stream &gt;# XACK命令告诉消费组处理成功XACK stream group 1618152751340-012.管道通过管道可以一次性发送多条命令并在执行完后一次性将结果返回，当一组命令中的每条命令都不依赖之前命令的执行结果时就可以将这组命令通过管道一起发出。二.LUA脚本Lua是一种高效的轻量级脚本语言。Lua在葡萄牙语中是“月亮”的意思，寓意着Lua是一种“卫星语言”，能够方便地嵌入其他编程语言中使用。1.数据类型 nil boolean number string table functionLua的变量分为全局变量和局部变量，在Redis脚本中不能使用全局变量，只允许使用局部变量以防止脚本之间相互影响。只有nil和false才为假，其余值，包括空字符串和0，都被认为是真值。2.关键字and，break，do，else，elseif，end，false，for，function，if，in，local，nil，not，or，repeat，return，then，true，until，while3.语法-- 为全局变量foo赋值foo = 1 -- 无须声明即可使用，默认值是nil print(foo) -- 删除全局变量foo的方法是将其赋值为nil。全局变量没有声明和未声明之分，只有是否nil之分 foo = nil -- 多重赋值local a, b, c = 1,2,3-- false，二者类型不同，不会进行自动类型转换print(1 == '1')-- false，对于表类型值比较的是二者的引用print({'foo'} == {'foo'}) -- 比较字符串和数字，手动进行类型转换print(1 == tonumber('1'))print('1' == tostring(1))-- 连接操作符 'hello world!'print('hello' .. ' ' .. 'world!')-- 取长度操作符，长度为5。print(#'hello')-- 条件语句if (foo==1) then-- 语句块elseif (foo==2) then-- 语句块else-- 语句块end-- 循环语句while foo==1 do -- 语句块endrepeat -- 语句块until foo==1for i = 1, 100 do -- 语句块end-- 表类型-- 将变量a赋值为一个空表a = {}-- 将field字段赋值value a['field'] = 'value'-- 打印内容为'value'，a.field是a['field']的语法糖 print(a.field) -- 也可以这样定义people = { name = 'Bob', age = 29}-- 打印的内容为'Bob'print(people.name) -- 索引为整数的时候，表和传统的数组一样，索引是从1开始的，而不是0。a = {}a[1] = 'Bob'a[2] = 'Jeff'a = {'Bob', 'Jeff'}print(a[1])-- 函数 return和break（用于跳出循环）语句必须是语句块中的最后一条语句，只能在end、else或until三者之一后面function (num) return num * numend4.EVALRedis的脚本执行是原子的，即脚本执行期间Redis不会执行其他命令。所有的命令都必须等待脚本执行完成后才能执行。为了防止某个脚本执行时间过长导致Redis无法提供服务（如陷入死循环），Redis提供了lua-time-limit参数来限制脚本的最长执行时间，默认为5秒。# EVAL命令需要提供脚本本身，脚本中使用的键。EVAL \"return redis.call('get', 'bar')\" 0# 多个参数EVAL \"local result = {}; for i = 1, #KEYS do local key = KEYS[i]; local value = ARGV[i]; local storedValue = redis.call('GET', key); table.insert(result, {key, storedValue, value}) end; return result\" 2 key1 key2 value11 value22三.持久化Redis支持两种方式的持久化，一种是RDB方式，另一种是AOF方式。前者会根据指定的规则“定时”将内存中的数据存储在硬盘上，而后者在每次执行命令后将命令本身记录下来。场景选择：如果对数据完整性要求较高，可以选择 AOF 持久化。如果对磁盘空间和恢复速度有更高的要求，可以选择 RDB 持久化。也可以同时使用 AOF 和 RDB 进行双重保障。1.RDBRDB（Redis DataBase）方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的所有数据生成一份副本并存储在硬盘上，这个过程即“快照”。快照过程： Redis使用fork函数复制一份当前进程（父进程）的副本（子进程） 父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件 当子进程写入所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。在运行fork()函数的时候，操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork()函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一条写命令），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是运行fork()函数那一刻的内存数据。写时复制策略也保证了在运行fork()函数的时刻虽然看上去生成了两份内存副本，但实际上内存的占用空间并不会增加一倍。Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。2.AOFAOF（Append-Only File）可以将Redis执行的每一条写命令追加到硬盘文件中，随着执行的命令越来越多，AOF文件的大小也会越来越大，每当达到一定条件时Redis就会自动重写AOF文件。四.集群1.复制当一个从数据库启动后，会向主数据库发送SYNC命令。同时主数据库接收到SYNC命令后会开始在后台保存快照（即RDB持久化的过程），并将保存快照期间接收到的命令缓存起来。当快照完成后，Redis会将快照文件和所有缓存的命令发送给从数据库。从数据库收到后，会载入快照文件并执行收到的缓存的命令。以上过程称为复制初始化。复制初始化结束后，主数据库每当收到写命令时就会将命令同步给从数据库，从而保证主从数据库数据一致。增量复制断线重连能够支持有条件的增量数据传输，当从数据库重新连接上主数据库后，主数据库只需要将断线期间执行的命令传送给从数据库，从而大大提高Redis复制的实用性。从数据库会存储主数据库的运行ID，在复制同步阶段，主数据库每将一条命令传送给从数据库时，都会同时把该命令存放到一个积压队列（backlog）中，并记录下当前积压队列中存放的命令的偏移量范围。2.哨兵监控主数据库和从数据库是否正常运行，当主数据库出现故障时，自动将从数据库转换为主数据库。3.集群集群支持几乎所有的单机实例支持的命令，对于涉及多键的命令（如MGET），如果每个键都位于同一个节点中，则可以正常支持，否则会提示错误。除此之外集群还有一个限制是只能使用默认的0号数据库，如果执行SELECT切换数据库则会提示错误。" }, { "title": "MySQL笔记", "url": "/posts/MySQL%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2017-12-31 16:00:00 +0000", "snippet": "一.SQL语句数据定义语言 (Data Definition Language, DDL)CREATE TABLE table_name ( column1 datatype, column2 datatype, ...);ALTER TABLE table_name ADD column_name datatype;DROP TABLE table_name;数据操纵语言...", "content": "一.SQL语句数据定义语言 (Data Definition Language, DDL)CREATE TABLE table_name ( column1 datatype, column2 datatype, ...);ALTER TABLE table_name ADD column_name datatype;DROP TABLE table_name;数据操纵语言（Data Manipulation Language, DML）INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);UPDATE table_name SET column1 = value1 WHERE condition;DELETE FROM table_name WHERE condition;数据查询语言（Data Query Language, DQL）SELECT column1, column2 FROM table WHERE condition;数据控制语言 (Data Control Language, DCL)DBA用来管理系统中的对象权限时所使用,例如：GRANT 和 REVOKE。-- privilege是授予的权限如SELECT、INSERT、UPDATE、DELETE等。-- object是权限作用的对象，可以是表、视图等数据库对象。-- user是被授权的用户。GRANT privilege ON object TO user;REVOKE privilege ON object FROM user;二.SQL优化1.设计表 使用合适的数据类型 建立索引 适当冗余字段2.SQL语句索引失效 隐式类型转换（当查询的字段与数据库定义字段的类型不匹配时，MySQL会尝试进行隐式类型转换）。 索引字段使用表达式计算。 索引字段使用函数。 索引字段使用左／左右模糊匹配。 组合索引非最左匹配。覆盖索引 一个包含查询所需字段的索引称为“覆盖索引”。MySQL只需要通过索引就可以返回查询所需要的数据，而不必在查到索引之后进行回表操作，减少了IO，提高了效率。插入操作 insert into values(),()…比insert into value()性能更高。 批量插入记录按顺序插入。SELECT(*) 统计行数的效率排序：count(字段) &lt; count(主键id) &lt; count(1)≈count(*)。 SHOW TABLE STATUS LIKE “table_name”。 增加LIMIT语句。3.工具explain语句 id：每个执行计划都有一个id，如果是一个联合查询，那么这里还将有多个id。 select_type：表示select查询类型，常见的有simple（普通查询，即没有联合查询、子查询）、primary（主查询）、union（union中后面的查询）、subquery（子查询）等。 table：当前执行计划查询的表，如果给表起别名了，则显示别名信息。 partitions：查询涉及的分区数。 type：表示从表中查询到行所执行的方式，查询方式是SQL优化中一个很重要的指标，结果值从好到差依次是system、const、eq_ref、ref、range、index、all。system/const表示只有一行数据匹配，此时根据索引查询一次就能找到对应的数据。eq_ref表示使用唯一索引扫描，常见于多表连接中使用主键和唯一索引作为关联条件。ref表示使用非唯一索引扫描，还可见于唯一索引最左原则匹配扫描。range表示索引范围扫描，比如&lt;、&gt;、between等操作。index表示索引全表扫描，此时遍历整个索引树。 possible_keys：可能使用的索引。 key：实际使用的索引。 key_len：当前使用的索引的长度。 ref：关联id等信息。rows：查找到记录所扫描的行数。 filtered：查找到所需记录占总扫描记录数的比例。 extra：额外的信息。show profile-- 查看是否支持profileSELECT @@have_profiling;SHOW PROFILES;SHOW PROFILE FOR QUERY id三.架构优化1.分库原则 垂直分库是根据业务进行划分的，将同一类业务相关的数据表划分在同一个库中。 水平分库是按照一定的规则对数据库进行划分。每个数据库中各个表的结构相同，数据存储在不同的数据库中。2.数据库架构主从模式：主节点会同步将数据复制给从节点，保证主从节点数据一致。同步模式 先复制Binlog日志，等Binlog日志全部复制到从节点后，主节点再提交事务。这种情况下主节点和从节点是保持同步的，主节点出现宕机也不会丢失数据。这种复制方式，我们称为同步复制。 先提交事务，再复制Binlog日志到从节点。这种情况下，提交事务和复制这两个流程在不同的线程中执行，互相不会等待，性能会比较好，但是存在丢失数据的风险。这种复制方式，我们称为异步复制。 用户发出写请求后，主库会执行写操作，并给从库发送同步请求，但主库不用等待所有从库的回复数据同步成功便可响应用户，也就是说主库可以等待一部分从库同步完成后，响应用户写操作执行成功。我们称为半同步复制。四.原理1.事务（Transaction）一组操作，要么成功、要么失败。特性 原子性（Atomicity）：事务作为一个整体被执行，不可分割，包含在其中的对数据库的操作要么全部被执行，要么都不执行。 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中，不会因为系统故障而失效。事务的隔离性是通过数据库锁的机制实现的。原子性和一致性是通过Undo Log来实现的。Undo Log的原理很简单：为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log），然后进行数据的修改；如果出现了错误或者用户执行了Rollback语句，系统就可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。持久性是通过Redo Log（重做日志）来实现的。和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只需将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化，系统可以根据Redo Log的内容将所有数据恢复到最新的状态。隔离级别 xxx 脏读 不可重复读 幻读 读未提交（read uncommitted） ✅ ✅ ✅ 读已提交（read committed） ❎ ✅ ✅ 可重复读（repeatable read） ❎ ❎ ✅ 串行化（serializable） ❎ ❎ ❎ 2.索引主键索引、唯一索引、普通索引和全文索引。3.日志日志分类 错误日志（Error Log）：错误日志记录了MySQL服务器发生的所有错误事件，包括启动、关闭、连接和查询等操作的错误信息，可用于故障排查。 普通查询日志（General Query Log）：记录了所有用户的连接开始时间和截止时间，以及发给MySQL数据库服务器的所有SQL指令。 慢查询日志（Slow Query Log）：慢查询日志记录了执行时间超过阈值的SQL语句，可用于优化查询性能。 二进制日志（Binary Log）：二进制日志记录了所有对数据库的修改，包括insert、update、delete等语句，以二进制的形式记录，可用于数据恢复、主从同步等场景。 撤销日志（Undo Log）：撤销日志记录了事务执行期间对数据的修改操作，用于支持回滚和MVCC功能。 重做日志（Redo Log）：是一种循环写入的日志文件，用于支持MySQL的事务和崩溃恢复机制。当MySQL执行事务时，所有对数据的修改操作都会被写入Redo Log中。Redo Log以追加的方式写入，当写满时会循环覆盖之前的记录。这样可以保证在发生宕机等异常情况时，可以通过Redo Log中保存的操作记录来恢复数据的一致性。 中继日志（Relay Log）：是指在主从复制中，从服务器上用来保存从主服务器接收到的二进制日志的一种日志文件。Binlog记录格式 基于语句的复制（Statement-Based Replication，SBR）基于语句的复制是MySQL默认的Binlog记录格式。它记录的是对数据库执行的SQL语句。当进行主从同步时，从服务器通过解析Binlog中的SQL语句来执行相同的操作。缺点是可能会导致主备不一致。 基于行的复制（Row-Based Replication，RBR）基于行的复制是一种将每一行数据的修改都记录在Binlog中的格式。当进行主从同步时，从服务器通过解析Binlog中的每一行数据的修改来进行同步。RBR的缺点是需要记录每一行数据的修改，因此会产生更多的Binlog数据，可能会降低性能。 混合复制（Mixed-Based Replication，MBR）混合复制是一种同时使用基于语句的复制和基于行的复制的格式。MySQL会自动选择最合适的复制方式来记录Binlog。五.问题1.DROP TABLE,TRUNCATE TABLE和DELETE FROM的区别？ DROP TABLE TRUNCATE TABLE DELETE FROM 表及其所有关系、索引、权限、触发器等将被永久删除 表行被永久删除 表行不会被永久删除 无法执行回滚操作来撤销 无法执行回滚操作来撤销 可以执行回滚操作来撤销 不能使用 where 条件 不能使用 where 条件 可以使用 where 条件 数据定义语言 (DDL) 语句 数据定义语言 (DDL) 语句 数据操作语言(DML) 语句 执行速度快 执行速度较快 执行速度慢 2.DATETIME和TIMESTAMP的差别？ 时区的优先级：会话时区&gt;数据库时区&gt;服务器时区 NOW(), CURRENT_TIMESTAMP(), CURRENT_TIME()函数受会话时区影响。 差别 DATETIME TIMESTAMP 8个字节 4个字节 1000-01-01 00:00:00 到 9999-12-31 23:59:59 1970-01-01 00:00:01 到 2038-01-19 03:14:07 读写不受会话时区影响 写入会根据会话时区转为UTC时区读出会把UTC时区转为会话时区 开发中实践：后端程序运行指定UTC时区，指定会话时区为UTC，写时使用数据库函数；客户端根据本地时区进行转换展示。-- 查看时区SHOW GLOBAL VARIABLES LIKE '%time_zone%';SELECT @@global.time_zone AS global_time_zone, @@session.time_zone AS session_time_zone;-- 修改会话时区SET time_zone = '+08:00';" }, { "title": "图解浏览器", "url": "/posts/%E5%9B%BE%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/", "categories": "", "tags": "", "date": "2017-12-01 00:00:00 +0000", "snippet": "当用户敲完回车键浏览器偷偷地做了什么？现在我们跟导航图片了解一下浏览器的工作流程。注意：请大家顺着序号阅读！恭喜你，已经看完了这张图片！现在我们把关注点放到第④步骤！这一步浏览器只做两件事情： 解析HTML代码并构建文档对象模型（DOM） 执行JavaScript代码每当解析到脚本元素时，浏览器就会停止构建DOM，开始执行JavaScript代码。这两件事情可能会交替执行多次。现在我们跟...", "content": "当用户敲完回车键浏览器偷偷地做了什么？现在我们跟导航图片了解一下浏览器的工作流程。注意：请大家顺着序号阅读！恭喜你，已经看完了这张图片！现在我们把关注点放到第④步骤！这一步浏览器只做两件事情： 解析HTML代码并构建文档对象模型（DOM） 执行JavaScript代码每当解析到脚本元素时，浏览器就会停止构建DOM，开始执行JavaScript代码。这两件事情可能会交替执行多次。现在我们跟导航图片了解一下构建页面工作流程：再次恭喜你，已经看完了这张图片！现在我们把关注点放到第⑤步骤！浏览器执行环境的核心思想：同一时刻只能执行一个代码片段，即所谓的单线程执行模型。浏览器会检查事件队列，没有在队列中检测到事件，则继续检查；在队列中检测到了事件，则取出该事件并执行相应的事件处理器；在这个过程中，余下的事件在事件队列中耐心等待，直到轮到它们被处理。放置事件的队列是在页面构建阶段和事件处理阶段以外。事件是异步的，事件类型有以下4类： 浏览器事件，例如当页面加载完成后或无法加载时 网络事件，例如来自服务器的响应（Ajax事件和服务器端事件）； 用户事件，例如鼠标单击、鼠标移动和键盘事件； 计时器事件，当timeout时间到期或又触发了一次时间间隔； 现在我们跟导航图片了解一下监听事件的工作流程。再一次恭喜你，已经看完了这张图片！现在我们以具体的鼠标事件来走一遍事件队列的工作流程。最后恭喜你，已经掌握了浏览器的工作流程！" } ]
